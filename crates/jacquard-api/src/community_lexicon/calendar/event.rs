// @generated by jacquard-lexicon. DO NOT EDIT.
//
// Lexicon: community.lexicon.calendar.event
//
// This file was automatically generated from Lexicon schemas.
// Any manual changes will be overwritten on the next regeneration.

///The event has been cancelled.
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    Hash,
    jacquard_derive::IntoStatic
)]
pub struct Cancelled;
impl std::fmt::Display for Cancelled {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "cancelled")
    }
}

///A hybrid event that takes place both online and offline.
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    Hash,
    jacquard_derive::IntoStatic
)]
pub struct Hybrid;
impl std::fmt::Display for Hybrid {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "hybrid")
    }
}

///An in-person event that takes place offline.
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    Hash,
    jacquard_derive::IntoStatic
)]
pub struct Inperson;
impl std::fmt::Display for Inperson {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "inperson")
    }
}

///A calendar event.
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct Event<'a> {
    ///Client-declared timestamp when the event was created.
    pub created_at: jacquard_common::types::string::Datetime,
    ///The description of the event.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub description: std::option::Option<jacquard_common::CowStr<'a>>,
    ///Client-declared timestamp when the event ends.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ends_at: std::option::Option<jacquard_common::types::string::Datetime>,
    ///The locations where the event takes place.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub locations: std::option::Option<Vec<EventLocationsItem<'a>>>,
    ///The attendance mode of the event.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub mode: std::option::Option<crate::community_lexicon::calendar::event::Mode<'a>>,
    ///The name of the event.
    #[serde(borrow)]
    pub name: jacquard_common::CowStr<'a>,
    ///Client-declared timestamp when the event starts.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub starts_at: std::option::Option<jacquard_common::types::string::Datetime>,
    ///The status of the event.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub status: std::option::Option<
        crate::community_lexicon::calendar::event::Status<'a>,
    >,
    ///URIs associated with the event.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub uris: std::option::Option<
        Vec<crate::community_lexicon::calendar::event::Uri<'a>>,
    >,
}

#[jacquard_derive::open_union]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(tag = "$type")]
#[serde(bound(deserialize = "'de: 'a"))]
pub enum EventLocationsItem<'a> {
    #[serde(rename = "community.lexicon.calendar.event#uri")]
    Uri(Box<crate::community_lexicon::calendar::event::Uri<'a>>),
    #[serde(rename = "community.lexicon.location.address")]
    Address(Box<crate::community_lexicon::location::address::Address<'a>>),
    #[serde(rename = "community.lexicon.location.fsq")]
    Fsq(Box<crate::community_lexicon::location::fsq::Fsq<'a>>),
    #[serde(rename = "community.lexicon.location.geo")]
    Geo(Box<crate::community_lexicon::location::geo::Geo<'a>>),
    #[serde(rename = "community.lexicon.location.hthree")]
    Hthree(Box<crate::community_lexicon::location::hthree::Hthree<'a>>),
}

impl jacquard_common::types::collection::Collection for Event<'_> {
    const NSID: &'static str = "community.lexicon.calendar.event";
}

///The mode of the event.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Mode<'a> {
    CommunityLexiconCalendarEventHybrid,
    CommunityLexiconCalendarEventInperson,
    CommunityLexiconCalendarEventVirtual,
    Other(jacquard_common::CowStr<'a>),
}

impl<'a> Mode<'a> {
    pub fn as_str(&self) -> &str {
        match self {
            Self::CommunityLexiconCalendarEventHybrid => {
                "community.lexicon.calendar.event#hybrid"
            }
            Self::CommunityLexiconCalendarEventInperson => {
                "community.lexicon.calendar.event#inperson"
            }
            Self::CommunityLexiconCalendarEventVirtual => {
                "community.lexicon.calendar.event#virtual"
            }
            Self::Other(s) => s.as_ref(),
        }
    }
}

impl<'a> From<&'a str> for Mode<'a> {
    fn from(s: &'a str) -> Self {
        match s {
            "community.lexicon.calendar.event#hybrid" => {
                Self::CommunityLexiconCalendarEventHybrid
            }
            "community.lexicon.calendar.event#inperson" => {
                Self::CommunityLexiconCalendarEventInperson
            }
            "community.lexicon.calendar.event#virtual" => {
                Self::CommunityLexiconCalendarEventVirtual
            }
            _ => Self::Other(jacquard_common::CowStr::from(s)),
        }
    }
}

impl<'a> From<String> for Mode<'a> {
    fn from(s: String) -> Self {
        match s.as_str() {
            "community.lexicon.calendar.event#hybrid" => {
                Self::CommunityLexiconCalendarEventHybrid
            }
            "community.lexicon.calendar.event#inperson" => {
                Self::CommunityLexiconCalendarEventInperson
            }
            "community.lexicon.calendar.event#virtual" => {
                Self::CommunityLexiconCalendarEventVirtual
            }
            _ => Self::Other(jacquard_common::CowStr::from(s)),
        }
    }
}

impl<'a> AsRef<str> for Mode<'a> {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

impl<'a> serde::Serialize for Mode<'a> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(self.as_str())
    }
}

impl<'de, 'a> serde::Deserialize<'de> for Mode<'a>
where
    'de: 'a,
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let s = <&'de str>::deserialize(deserializer)?;
        Ok(Self::from(s))
    }
}

impl jacquard_common::IntoStatic for Mode<'_> {
    type Output = Mode<'static>;
    fn into_static(self) -> Self::Output {
        match self {
            Mode::CommunityLexiconCalendarEventHybrid => {
                Mode::CommunityLexiconCalendarEventHybrid
            }
            Mode::CommunityLexiconCalendarEventInperson => {
                Mode::CommunityLexiconCalendarEventInperson
            }
            Mode::CommunityLexiconCalendarEventVirtual => {
                Mode::CommunityLexiconCalendarEventVirtual
            }
            Mode::Other(v) => Mode::Other(v.into_static()),
        }
    }
}

///The event has been created, but not finalized.
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    Hash,
    jacquard_derive::IntoStatic
)]
pub struct Planned;
impl std::fmt::Display for Planned {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "planned")
    }
}

///The event has been postponed and a new start date has not been set.
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    Hash,
    jacquard_derive::IntoStatic
)]
pub struct Postponed;
impl std::fmt::Display for Postponed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "postponed")
    }
}

///The event has been rescheduled.
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    Hash,
    jacquard_derive::IntoStatic
)]
pub struct Rescheduled;
impl std::fmt::Display for Rescheduled {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "rescheduled")
    }
}

///The event has been created and scheduled.
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    Hash,
    jacquard_derive::IntoStatic
)]
pub struct Scheduled;
impl std::fmt::Display for Scheduled {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "scheduled")
    }
}

///The status of the event.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Status<'a> {
    CommunityLexiconCalendarEventCancelled,
    CommunityLexiconCalendarEventPlanned,
    CommunityLexiconCalendarEventPostponed,
    CommunityLexiconCalendarEventRescheduled,
    CommunityLexiconCalendarEventScheduled,
    Other(jacquard_common::CowStr<'a>),
}

impl<'a> Status<'a> {
    pub fn as_str(&self) -> &str {
        match self {
            Self::CommunityLexiconCalendarEventCancelled => {
                "community.lexicon.calendar.event#cancelled"
            }
            Self::CommunityLexiconCalendarEventPlanned => {
                "community.lexicon.calendar.event#planned"
            }
            Self::CommunityLexiconCalendarEventPostponed => {
                "community.lexicon.calendar.event#postponed"
            }
            Self::CommunityLexiconCalendarEventRescheduled => {
                "community.lexicon.calendar.event#rescheduled"
            }
            Self::CommunityLexiconCalendarEventScheduled => {
                "community.lexicon.calendar.event#scheduled"
            }
            Self::Other(s) => s.as_ref(),
        }
    }
}

impl<'a> From<&'a str> for Status<'a> {
    fn from(s: &'a str) -> Self {
        match s {
            "community.lexicon.calendar.event#cancelled" => {
                Self::CommunityLexiconCalendarEventCancelled
            }
            "community.lexicon.calendar.event#planned" => {
                Self::CommunityLexiconCalendarEventPlanned
            }
            "community.lexicon.calendar.event#postponed" => {
                Self::CommunityLexiconCalendarEventPostponed
            }
            "community.lexicon.calendar.event#rescheduled" => {
                Self::CommunityLexiconCalendarEventRescheduled
            }
            "community.lexicon.calendar.event#scheduled" => {
                Self::CommunityLexiconCalendarEventScheduled
            }
            _ => Self::Other(jacquard_common::CowStr::from(s)),
        }
    }
}

impl<'a> From<String> for Status<'a> {
    fn from(s: String) -> Self {
        match s.as_str() {
            "community.lexicon.calendar.event#cancelled" => {
                Self::CommunityLexiconCalendarEventCancelled
            }
            "community.lexicon.calendar.event#planned" => {
                Self::CommunityLexiconCalendarEventPlanned
            }
            "community.lexicon.calendar.event#postponed" => {
                Self::CommunityLexiconCalendarEventPostponed
            }
            "community.lexicon.calendar.event#rescheduled" => {
                Self::CommunityLexiconCalendarEventRescheduled
            }
            "community.lexicon.calendar.event#scheduled" => {
                Self::CommunityLexiconCalendarEventScheduled
            }
            _ => Self::Other(jacquard_common::CowStr::from(s)),
        }
    }
}

impl<'a> AsRef<str> for Status<'a> {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

impl<'a> serde::Serialize for Status<'a> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(self.as_str())
    }
}

impl<'de, 'a> serde::Deserialize<'de> for Status<'a>
where
    'de: 'a,
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let s = <&'de str>::deserialize(deserializer)?;
        Ok(Self::from(s))
    }
}

impl jacquard_common::IntoStatic for Status<'_> {
    type Output = Status<'static>;
    fn into_static(self) -> Self::Output {
        match self {
            Status::CommunityLexiconCalendarEventCancelled => {
                Status::CommunityLexiconCalendarEventCancelled
            }
            Status::CommunityLexiconCalendarEventPlanned => {
                Status::CommunityLexiconCalendarEventPlanned
            }
            Status::CommunityLexiconCalendarEventPostponed => {
                Status::CommunityLexiconCalendarEventPostponed
            }
            Status::CommunityLexiconCalendarEventRescheduled => {
                Status::CommunityLexiconCalendarEventRescheduled
            }
            Status::CommunityLexiconCalendarEventScheduled => {
                Status::CommunityLexiconCalendarEventScheduled
            }
            Status::Other(v) => Status::Other(v.into_static()),
        }
    }
}

///A URI associated with the event.
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct Uri<'a> {
    ///The display name of the URI.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub name: std::option::Option<jacquard_common::CowStr<'a>>,
    #[serde(borrow)]
    pub uri: jacquard_common::types::string::Uri<'a>,
}

///A virtual event that takes place online.
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    Hash,
    jacquard_derive::IntoStatic
)]
pub struct Virtual;
impl std::fmt::Display for Virtual {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "virtual")
    }
}