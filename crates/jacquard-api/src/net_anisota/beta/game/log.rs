// @generated by jacquard-lexicon. DO NOT EDIT.
//
// Lexicon: net.anisota.beta.game.log
//
// This file was automatically generated from Lexicon schemas.
// Any manual changes will be overwritten on the next regeneration.

///Details about item/specimen collection
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct CollectionData<'a> {
    ///Catch probability for specimens (decimal string between 0.0 and 1.0)
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub catch_probability: std::option::Option<jacquard_common::CowStr<'a>>,
    ///URI of the created inventory record
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub inventory_record_uri: std::option::Option<jacquard_common::CowStr<'a>>,
    ///How the item was obtained
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub method: std::option::Option<jacquard_common::CowStr<'a>>,
    ///URI of the created specimen record
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub specimen_record_uri: std::option::Option<jacquard_common::CowStr<'a>>,
    ///Whether collection was successful
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub success: std::option::Option<bool>,
    ///Milliseconds between card generation and collection
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub time_since_generation: std::option::Option<i64>,
    ///Milliseconds between card being viewed and collected
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub time_since_viewed: std::option::Option<i64>,
}

///Details about daily rewards claim
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct DailyRewardsData<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub reward_items: std::option::Option<
        Vec<crate::net_anisota::beta::game::log::RewardItem<'a>>,
    >,
    ///Number of rewards claimed
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rewards_count: std::option::Option<i64>,
    ///Current daily reward streak
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub streak: std::option::Option<i64>,
    ///Milliseconds since last claim
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub time_since_last_claim: std::option::Option<i64>,
}

///Context about the feed when event occurred
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct FeedContext<'a> {
    ///URI of the feed being viewed
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub feed_uri: std::option::Option<jacquard_common::CowStr<'a>>,
    ///Number of game cards injected
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub game_card_count: std::option::Option<i64>,
    ///Number of posts in the feed
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub post_count: std::option::Option<i64>,
    ///User's scroll position or card index
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub scroll_position: std::option::Option<i64>,
}

///Details about game cards generated or interacted with
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct GameCardData<'a> {
    ///Type of game card
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub card_type: std::option::Option<jacquard_common::CowStr<'a>>,
    ///Unique identifier for the game card
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub card_uri: std::option::Option<jacquard_common::CowStr<'a>>,
    ///Random seed used for generation (for verification)
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub generation_seed: std::option::Option<jacquard_common::CowStr<'a>>,
    ///Position where card was injected in feed
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub injection_position: std::option::Option<i64>,
    ///ID of the item/specimen
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub item_id: std::option::Option<jacquard_common::CowStr<'a>>,
    ///Quantity of items
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub quantity: std::option::Option<i64>,
    ///Rarity of the item/specimen
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub rarity: std::option::Option<jacquard_common::CowStr<'a>>,
}

///Details about item usage
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct ItemUsageData<'a> {
    ///Effect that was applied
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub effect_applied: std::option::Option<jacquard_common::CowStr<'a>>,
    ///URI of the modified inventory record
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub inventory_record_uri: std::option::Option<jacquard_common::CowStr<'a>>,
    ///ID of the item used
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub item_id: std::option::Option<jacquard_common::CowStr<'a>>,
    ///Quantity of the item used
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub quantity_used: std::option::Option<i64>,
    ///Remaining quantity after use
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub remaining_quantity: std::option::Option<i64>,
}

///A log record for tracking game events and user actions for provenance and anti-bot analysis
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct Log<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub collection_data: std::option::Option<
        crate::net_anisota::beta::game::log::CollectionData<'a>,
    >,
    ///When the log record was created
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub created_at: std::option::Option<jacquard_common::types::string::Datetime>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub daily_rewards_data: std::option::Option<
        crate::net_anisota::beta::game::log::DailyRewardsData<'a>,
    >,
    ///Type of event being logged
    #[serde(borrow)]
    pub event_type: jacquard_common::CowStr<'a>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub feed_context: std::option::Option<
        crate::net_anisota::beta::game::log::FeedContext<'a>,
    >,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub game_card_data: std::option::Option<
        crate::net_anisota::beta::game::log::GameCardData<'a>,
    >,
    ///Unique ID of the game card this event relates to
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub game_card_id: std::option::Option<jacquard_common::CowStr<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub item_usage_data: std::option::Option<
        crate::net_anisota::beta::game::log::ItemUsageData<'a>,
    >,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub metadata: std::option::Option<crate::net_anisota::beta::game::log::Metadata<'a>>,
    ///URI of the parent log record that triggered this event
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub parent_log_uri: std::option::Option<jacquard_common::CowStr<'a>>,
    ///URI of the root log record in this event chain
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub root_log_uri: std::option::Option<jacquard_common::CowStr<'a>>,
    ///Unique session identifier to group related events
    #[serde(borrow)]
    pub session_id: jacquard_common::CowStr<'a>,
    ///URI of the session record this event belongs to (at://did/collection/rkey)
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub session_uri: std::option::Option<jacquard_common::CowStr<'a>>,
    ///When the event occurred (ISO 8601)
    pub timestamp: jacquard_common::types::string::Datetime,
}

impl jacquard_common::types::collection::Collection for Log<'_> {
    const NSID: &'static str = "net.anisota.beta.game.log";
}

///Additional event-specific metadata
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct Metadata<'a> {
    ///Version of the client application
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub client_version: std::option::Option<jacquard_common::CowStr<'a>>,
    ///Network latency in milliseconds
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub network_latency: std::option::Option<i64>,
    ///Performance timing data
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub performance_timings: std::option::Option<
        jacquard_common::types::value::Data<'a>,
    >,
    ///Platform (web, mobile, etc.)
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub platform: std::option::Option<jacquard_common::CowStr<'a>>,
}

///Item received as a reward
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct RewardItem<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub item_id: std::option::Option<jacquard_common::CowStr<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub quantity: std::option::Option<i64>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub rarity: std::option::Option<jacquard_common::CowStr<'a>>,
}