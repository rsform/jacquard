// @generated by jacquard-lexicon. DO NOT EDIT.
//
// Lexicon: net.anisota.beta.game.log
//
// This file was automatically generated from Lexicon schemas.
// Any manual changes will be overwritten on the next regeneration.

/// Details about item/specimen collection
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic,
    bon::Builder
)]
#[serde(rename_all = "camelCase")]
pub struct CollectionData<'a> {
    /// Catch probability for specimens (decimal string between 0.0 and 1.0)
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    #[serde(borrow)]
    pub catch_probability: Option<jacquard_common::CowStr<'a>>,
    /// URI of the created inventory record
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    #[serde(borrow)]
    pub inventory_record_uri: Option<jacquard_common::CowStr<'a>>,
    /// How the item was obtained
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    #[serde(borrow)]
    pub method: Option<jacquard_common::CowStr<'a>>,
    /// URI of the created specimen record
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    #[serde(borrow)]
    pub specimen_record_uri: Option<jacquard_common::CowStr<'a>>,
    /// Whether collection was successful
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    pub success: Option<bool>,
    /// Milliseconds between card generation and collection
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    pub time_since_generation: Option<i64>,
    /// Milliseconds between card being viewed and collected
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    pub time_since_viewed: Option<i64>,
}

/// Details about daily rewards claim
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic,
    bon::Builder
)]
#[serde(rename_all = "camelCase")]
pub struct DailyRewardsData<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    #[serde(borrow)]
    pub reward_items: Option<Vec<crate::net_anisota::beta::game::log::RewardItem<'a>>>,
    /// Number of rewards claimed
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    pub rewards_count: Option<i64>,
    /// Current daily reward streak
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    pub streak: Option<i64>,
    /// Milliseconds since last claim
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    pub time_since_last_claim: Option<i64>,
}

/// Context about the feed when event occurred
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic,
    bon::Builder
)]
#[serde(rename_all = "camelCase")]
pub struct FeedContext<'a> {
    /// URI of the feed being viewed
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    #[serde(borrow)]
    pub feed_uri: Option<jacquard_common::CowStr<'a>>,
    /// Number of game cards injected
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    pub game_card_count: Option<i64>,
    /// Number of posts in the feed
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    pub post_count: Option<i64>,
    /// User's scroll position or card index
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    pub scroll_position: Option<i64>,
}

/// Details about game cards generated or interacted with
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic,
    bon::Builder
)]
#[serde(rename_all = "camelCase")]
pub struct GameCardData<'a> {
    /// Type of game card
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    #[serde(borrow)]
    pub card_type: Option<jacquard_common::CowStr<'a>>,
    /// Unique identifier for the game card
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    #[serde(borrow)]
    pub card_uri: Option<jacquard_common::CowStr<'a>>,
    /// Random seed used for generation (for verification)
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    #[serde(borrow)]
    pub generation_seed: Option<jacquard_common::CowStr<'a>>,
    /// Position where card was injected in feed
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    pub injection_position: Option<i64>,
    /// ID of the item/specimen
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    #[serde(borrow)]
    pub item_id: Option<jacquard_common::CowStr<'a>>,
    /// Quantity of items
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    pub quantity: Option<i64>,
    /// Rarity of the item/specimen
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    #[serde(borrow)]
    pub rarity: Option<jacquard_common::CowStr<'a>>,
}

/// Details about item usage
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic,
    bon::Builder
)]
#[serde(rename_all = "camelCase")]
pub struct ItemUsageData<'a> {
    /// Effect that was applied
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    #[serde(borrow)]
    pub effect_applied: Option<jacquard_common::CowStr<'a>>,
    /// URI of the modified inventory record
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    #[serde(borrow)]
    pub inventory_record_uri: Option<jacquard_common::CowStr<'a>>,
    /// ID of the item used
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    #[serde(borrow)]
    pub item_id: Option<jacquard_common::CowStr<'a>>,
    /// Quantity of the item used
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    pub quantity_used: Option<i64>,
    /// Remaining quantity after use
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    pub remaining_quantity: Option<i64>,
}

/// A log record for tracking game events and user actions for provenance and anti-bot analysis
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic,
    bon::Builder
)]
#[serde(rename_all = "camelCase")]
pub struct Log<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    #[serde(borrow)]
    pub collection_data: Option<crate::net_anisota::beta::game::log::CollectionData<'a>>,
    /// When the log record was created
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    pub created_at: Option<jacquard_common::types::string::Datetime>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    #[serde(borrow)]
    pub daily_rewards_data: Option<
        crate::net_anisota::beta::game::log::DailyRewardsData<'a>,
    >,
    /// Type of event being logged
    #[serde(borrow)]
    #[builder(into)]
    pub event_type: jacquard_common::CowStr<'a>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    #[serde(borrow)]
    pub feed_context: Option<crate::net_anisota::beta::game::log::FeedContext<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    #[serde(borrow)]
    pub game_card_data: Option<crate::net_anisota::beta::game::log::GameCardData<'a>>,
    /// Unique ID of the game card this event relates to
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    #[serde(borrow)]
    pub game_card_id: Option<jacquard_common::CowStr<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    #[serde(borrow)]
    pub item_usage_data: Option<crate::net_anisota::beta::game::log::ItemUsageData<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    #[serde(borrow)]
    pub metadata: Option<crate::net_anisota::beta::game::log::Metadata<'a>>,
    /// URI of the parent log record that triggered this event
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    #[serde(borrow)]
    pub parent_log_uri: Option<jacquard_common::CowStr<'a>>,
    /// URI of the root log record in this event chain
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    #[serde(borrow)]
    pub root_log_uri: Option<jacquard_common::CowStr<'a>>,
    /// Unique session identifier to group related events
    #[serde(borrow)]
    #[builder(into)]
    pub session_id: jacquard_common::CowStr<'a>,
    /// URI of the session record this event belongs to (at://did/collection/rkey)
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    #[serde(borrow)]
    pub session_uri: Option<jacquard_common::CowStr<'a>>,
    /// When the event occurred (ISO 8601)
    pub timestamp: jacquard_common::types::string::Datetime,
}

/// Typed wrapper for GetRecord response with this collection's record type.
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct LogGetRecordOutput<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub cid: std::option::Option<jacquard_common::types::string::Cid<'a>>,
    #[serde(borrow)]
    pub uri: jacquard_common::types::string::AtUri<'a>,
    #[serde(borrow)]
    pub value: Log<'a>,
}

/// Marker type for deserializing records from this collection.
pub struct LogRecord;
impl jacquard_common::xrpc::XrpcResp for LogRecord {
    const NSID: &'static str = "net.anisota.beta.game.log";
    const ENCODING: &'static str = "application/json";
    type Output<'de> = LogGetRecordOutput<'de>;
    type Err<'de> = jacquard_common::types::collection::RecordError<'de>;
}

impl jacquard_common::types::collection::Collection for Log<'_> {
    const NSID: &'static str = "net.anisota.beta.game.log";
    type Record = LogRecord;
}

impl From<LogGetRecordOutput<'_>> for Log<'_> {
    fn from(output: LogGetRecordOutput<'_>) -> Self {
        use jacquard_common::IntoStatic;
        output.value.into_static()
    }
}

/// Additional event-specific metadata
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic,
    bon::Builder
)]
#[serde(rename_all = "camelCase")]
pub struct Metadata<'a> {
    /// Version of the client application
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    #[serde(borrow)]
    pub client_version: Option<jacquard_common::CowStr<'a>>,
    /// Network latency in milliseconds
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    pub network_latency: Option<i64>,
    /// Performance timing data
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    #[serde(borrow)]
    pub performance_timings: Option<jacquard_common::types::value::Data<'a>>,
    /// Platform (web, mobile, etc.)
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    #[serde(borrow)]
    pub platform: Option<jacquard_common::CowStr<'a>>,
}

/// Item received as a reward
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic,
    bon::Builder
)]
#[serde(rename_all = "camelCase")]
pub struct RewardItem<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    #[serde(borrow)]
    pub item_id: Option<jacquard_common::CowStr<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    pub quantity: Option<i64>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    #[serde(borrow)]
    pub rarity: Option<jacquard_common::CowStr<'a>>,
}