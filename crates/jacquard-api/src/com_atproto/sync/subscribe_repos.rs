// @generated by jacquard-lexicon. DO NOT EDIT.
//
// Lexicon: com.atproto.sync.subscribeRepos
//
// This file was automatically generated from Lexicon schemas.
// Any manual changes will be overwritten on the next regeneration.

///Represents a change to an account's status on a host (eg, PDS or Relay). The semantics of this event are that the status is at the host which emitted the event, not necessarily that at the currently active PDS. Eg, a Relay takedown would emit a takedown with active=false, even if the PDS is still active.
#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct Account<'a> {
    ///Indicates that the account has a repository which can be fetched from the host that emitted this event.
    pub active: bool,
    #[serde(borrow)]
    pub did: jacquard_common::types::string::Did<'a>,
    pub seq: i64,
    ///If active=false, this optional field indicates a reason for why the account is not active.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub status: std::option::Option<jacquard_common::CowStr<'a>>,
    pub time: jacquard_common::types::string::Datetime,
}

impl jacquard_common::IntoStatic for Account<'_> {
    type Output = Account<'static>;
    fn into_static(self) -> Self::Output {
        Account {
            active: self.active.into_static(),
            did: self.did.into_static(),
            seq: self.seq.into_static(),
            status: self.status.into_static(),
            time: self.time.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

///Represents an update of repository state. Note that empty commits are allowed, which include no repo data changes, but an update to rev and signature.
#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct Commit<'a> {
    #[serde(borrow)]
    pub blobs: Vec<jacquard_common::types::cid::CidLink<'a>>,
    ///CAR file containing relevant blocks, as a diff since the previous repo state. The commit must be included as a block, and the commit block CID must be the first entry in the CAR header 'roots' list.
    pub blocks: bytes::Bytes,
    ///Repo commit object CID.
    #[serde(borrow)]
    pub commit: jacquard_common::types::cid::CidLink<'a>,
    #[serde(borrow)]
    pub ops: Vec<crate::com_atproto::sync::subscribe_repos::RepoOp<'a>>,
    ///The root CID of the MST tree for the previous commit from this repo (indicated by the 'since' revision field in this message). Corresponds to the 'data' field in the repo commit object. NOTE: this field is effectively required for the 'inductive' version of firehose.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub prev_data: std::option::Option<jacquard_common::types::cid::CidLink<'a>>,
    ///DEPRECATED -- unused
    pub rebase: bool,
    ///The repo this event comes from. Note that all other message types name this field 'did'.
    #[serde(borrow)]
    pub repo: jacquard_common::types::string::Did<'a>,
    ///The rev of the emitted commit. Note that this information is also in the commit object included in blocks, unless this is a tooBig event.
    pub rev: jacquard_common::types::string::Tid,
    ///The stream sequence number of this message.
    pub seq: i64,
    ///The rev of the last emitted commit from this repo (if any).
    pub since: jacquard_common::types::string::Tid,
    ///Timestamp of when this message was originally broadcast.
    pub time: jacquard_common::types::string::Datetime,
    ///DEPRECATED -- replaced by #sync event and data limits. Indicates that this commit contained too many ops, or data size was too large. Consumers will need to make a separate request to get missing data.
    pub too_big: bool,
}

impl jacquard_common::IntoStatic for Commit<'_> {
    type Output = Commit<'static>;
    fn into_static(self) -> Self::Output {
        Commit {
            blobs: self.blobs.into_static(),
            blocks: self.blocks.into_static(),
            commit: self.commit.into_static(),
            ops: self.ops.into_static(),
            prev_data: self.prev_data.into_static(),
            rebase: self.rebase.into_static(),
            repo: self.repo.into_static(),
            rev: self.rev.into_static(),
            seq: self.seq.into_static(),
            since: self.since.into_static(),
            time: self.time.into_static(),
            too_big: self.too_big.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

///Represents a change to an account's identity. Could be an updated handle, signing key, or pds hosting endpoint. Serves as a prod to all downstream services to refresh their identity cache.
#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct Identity<'a> {
    #[serde(borrow)]
    pub did: jacquard_common::types::string::Did<'a>,
    ///The current handle for the account, or 'handle.invalid' if validation fails. This field is optional, might have been validated or passed-through from an upstream source. Semantics and behaviors for PDS vs Relay may evolve in the future; see atproto specs for more details.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub handle: std::option::Option<jacquard_common::types::string::Handle<'a>>,
    pub seq: i64,
    pub time: jacquard_common::types::string::Datetime,
}

impl jacquard_common::IntoStatic for Identity<'_> {
    type Output = Identity<'static>;
    fn into_static(self) -> Self::Output {
        Identity {
            did: self.did.into_static(),
            handle: self.handle.into_static(),
            seq: self.seq.into_static(),
            time: self.time.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct Info<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub message: std::option::Option<jacquard_common::CowStr<'a>>,
    #[serde(borrow)]
    pub name: jacquard_common::CowStr<'a>,
}

impl jacquard_common::IntoStatic for Info<'_> {
    type Output = Info<'static>;
    fn into_static(self) -> Self::Output {
        Info {
            message: self.message.into_static(),
            name: self.name.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct SubscribeRepos {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cursor: std::option::Option<i64>,
}

impl jacquard_common::IntoStatic for SubscribeRepos {
    type Output = SubscribeRepos;
    fn into_static(self) -> Self::Output {
        self
    }
}

#[jacquard_derive::open_union]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(tag = "$type")]
#[serde(bound(deserialize = "'de: 'a"))]
pub enum SubscribeReposMessage<'a> {
    #[serde(rename = "#commit")]
    Commit(Box<jacquard_common::types::value::Data<'a>>),
    #[serde(rename = "#sync")]
    Sync(Box<jacquard_common::types::value::Data<'a>>),
    #[serde(rename = "#identity")]
    Identity(Box<jacquard_common::types::value::Data<'a>>),
    #[serde(rename = "#account")]
    Account(Box<jacquard_common::types::value::Data<'a>>),
    #[serde(rename = "#info")]
    Info(Box<jacquard_common::types::value::Data<'a>>),
}

impl jacquard_common::IntoStatic for SubscribeReposMessage<'_> {
    type Output = SubscribeReposMessage<'static>;
    fn into_static(self) -> Self::Output {
        match self {
            SubscribeReposMessage::Commit(v) => {
                SubscribeReposMessage::Commit(v.into_static())
            }
            SubscribeReposMessage::Sync(v) => {
                SubscribeReposMessage::Sync(v.into_static())
            }
            SubscribeReposMessage::Identity(v) => {
                SubscribeReposMessage::Identity(v.into_static())
            }
            SubscribeReposMessage::Account(v) => {
                SubscribeReposMessage::Account(v.into_static())
            }
            SubscribeReposMessage::Info(v) => {
                SubscribeReposMessage::Info(v.into_static())
            }
            SubscribeReposMessage::Unknown(v) => {
                SubscribeReposMessage::Unknown(v.into_static())
            }
        }
    }
}

#[jacquard_derive::open_union]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    thiserror::Error,
    miette::Diagnostic
)]
#[serde(tag = "error", content = "message")]
#[serde(bound(deserialize = "'de: 'a"))]
pub enum SubscribeReposError<'a> {
    #[serde(rename = "FutureCursor")]
    FutureCursor(std::option::Option<String>),
    ///If the consumer of the stream can not keep up with events, and a backlog gets too large, the server will drop the connection.
    #[serde(rename = "ConsumerTooSlow")]
    ConsumerTooSlow(std::option::Option<String>),
}

impl std::fmt::Display for SubscribeReposError<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::FutureCursor(msg) => {
                write!(f, "FutureCursor")?;
                if let Some(msg) = msg {
                    write!(f, ": {}", msg)?;
                }
                Ok(())
            }
            Self::ConsumerTooSlow(msg) => {
                write!(f, "ConsumerTooSlow")?;
                if let Some(msg) = msg {
                    write!(f, ": {}", msg)?;
                }
                Ok(())
            }
            Self::Unknown(err) => write!(f, "Unknown error: {:?}", err),
        }
    }
}

impl jacquard_common::IntoStatic for SubscribeReposError<'_> {
    type Output = SubscribeReposError<'static>;
    fn into_static(self) -> Self::Output {
        match self {
            SubscribeReposError::FutureCursor(v) => {
                SubscribeReposError::FutureCursor(v.into_static())
            }
            SubscribeReposError::ConsumerTooSlow(v) => {
                SubscribeReposError::ConsumerTooSlow(v.into_static())
            }
            SubscribeReposError::Unknown(v) => {
                SubscribeReposError::Unknown(v.into_static())
            }
        }
    }
}

///A repo operation, ie a mutation of a single record.
#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct RepoOp<'a> {
    #[serde(borrow)]
    pub action: jacquard_common::CowStr<'a>,
    ///For creates and updates, the new record CID. For deletions, null.
    #[serde(borrow)]
    pub cid: jacquard_common::types::cid::CidLink<'a>,
    #[serde(borrow)]
    pub path: jacquard_common::CowStr<'a>,
    ///For updates and deletes, the previous record CID (required for inductive firehose). For creations, field should not be defined.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub prev: std::option::Option<jacquard_common::types::cid::CidLink<'a>>,
}

impl jacquard_common::IntoStatic for RepoOp<'_> {
    type Output = RepoOp<'static>;
    fn into_static(self) -> Self::Output {
        RepoOp {
            action: self.action.into_static(),
            cid: self.cid.into_static(),
            path: self.path.into_static(),
            prev: self.prev.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

///Updates the repo to a new state, without necessarily including that state on the firehose. Used to recover from broken commit streams, data loss incidents, or in situations where upstream host does not know recent state of the repository.
#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct Sync<'a> {
    ///CAR file containing the commit, as a block. The CAR header must include the commit block CID as the first 'root'.
    pub blocks: bytes::Bytes,
    ///The account this repo event corresponds to. Must match that in the commit object.
    #[serde(borrow)]
    pub did: jacquard_common::types::string::Did<'a>,
    ///The rev of the commit. This value must match that in the commit object.
    #[serde(borrow)]
    pub rev: jacquard_common::CowStr<'a>,
    ///The stream sequence number of this message.
    pub seq: i64,
    ///Timestamp of when this message was originally broadcast.
    pub time: jacquard_common::types::string::Datetime,
}

impl jacquard_common::IntoStatic for Sync<'_> {
    type Output = Sync<'static>;
    fn into_static(self) -> Self::Output {
        Sync {
            blocks: self.blocks.into_static(),
            did: self.did.into_static(),
            rev: self.rev.into_static(),
            seq: self.seq.into_static(),
            time: self.time.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}