// @generated by jacquard-lexicon. DO NOT EDIT.
//
// Lexicon: app.bsky.feed.defs
//
// This file was automatically generated from Lexicon schemas.
// Any manual changes will be overwritten on the next regeneration.

pub mod describe_feed_generator;
pub mod generator;
pub mod get_actor_feeds;
pub mod get_actor_likes;
pub mod get_author_feed;
pub mod get_feed;
pub mod get_feed_generator;
pub mod get_feed_generators;
pub mod get_feed_skeleton;
pub mod get_likes;
pub mod get_list_feed;
pub mod get_post_thread;
pub mod get_posts;
pub mod get_quotes;
pub mod get_reposted_by;
pub mod get_suggested_feeds;
pub mod get_timeline;
pub mod like;
pub mod post;
pub mod postgate;
pub mod repost;
pub mod search_posts;
pub mod send_interactions;
pub mod threadgate;

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct BlockedAuthor<'a> {
    #[serde(borrow)]
    pub did: jacquard_common::types::string::Did<'a>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub viewer: std::option::Option<crate::app_bsky::actor::ViewerState<'a>>,
}

impl jacquard_common::IntoStatic for BlockedAuthor<'_> {
    type Output = BlockedAuthor<'static>;
    fn into_static(self) -> Self::Output {
        BlockedAuthor {
            did: self.did.into_static(),
            viewer: self.viewer.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct BlockedPost<'a> {
    #[serde(borrow)]
    pub author: crate::app_bsky::feed::BlockedAuthor<'a>,
    pub blocked: bool,
    #[serde(borrow)]
    pub uri: jacquard_common::types::string::AtUri<'a>,
}

impl jacquard_common::IntoStatic for BlockedPost<'_> {
    type Output = BlockedPost<'static>;
    fn into_static(self) -> Self::Output {
        BlockedPost {
            author: self.author.into_static(),
            blocked: self.blocked.into_static(),
            uri: self.uri.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct FeedViewPost<'a> {
    ///Context provided by feed generator that may be passed back alongside interactions.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub feed_context: std::option::Option<jacquard_common::CowStr<'a>>,
    #[serde(borrow)]
    pub post: crate::app_bsky::feed::PostView<'a>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub reason: std::option::Option<FeedViewPostRecordReason<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub reply: std::option::Option<crate::app_bsky::feed::ReplyRef<'a>>,
    ///Unique identifier per request that may be passed back alongside interactions.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub req_id: std::option::Option<jacquard_common::CowStr<'a>>,
}

#[jacquard_derive::open_union]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(tag = "$type")]
#[serde(bound(deserialize = "'de: 'a"))]
pub enum FeedViewPostRecordReason<'a> {}
impl jacquard_common::IntoStatic for FeedViewPostRecordReason<'_> {
    type Output = FeedViewPostRecordReason<'static>;
    fn into_static(self) -> Self::Output {
        match self {
            FeedViewPostRecordReason::Unknown(v) => {
                FeedViewPostRecordReason::Unknown(v.into_static())
            }
        }
    }
}

impl jacquard_common::IntoStatic for FeedViewPost<'_> {
    type Output = FeedViewPost<'static>;
    fn into_static(self) -> Self::Output {
        FeedViewPost {
            feed_context: self.feed_context.into_static(),
            post: self.post.into_static(),
            reason: self.reason.into_static(),
            reply: self.reply.into_static(),
            req_id: self.req_id.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct GeneratorView<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub accepts_interactions: std::option::Option<bool>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub avatar: std::option::Option<jacquard_common::types::string::Uri<'a>>,
    #[serde(borrow)]
    pub cid: jacquard_common::types::string::Cid<'a>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub content_mode: std::option::Option<jacquard_common::CowStr<'a>>,
    #[serde(borrow)]
    pub creator: crate::app_bsky::actor::ProfileView<'a>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub description: std::option::Option<jacquard_common::CowStr<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub description_facets: std::option::Option<
        Vec<crate::app_bsky::richtext::facet::Facet<'a>>,
    >,
    #[serde(borrow)]
    pub did: jacquard_common::types::string::Did<'a>,
    #[serde(borrow)]
    pub display_name: jacquard_common::CowStr<'a>,
    pub indexed_at: jacquard_common::types::string::Datetime,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub labels: std::option::Option<Vec<crate::com_atproto::label::Label<'a>>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub like_count: std::option::Option<i64>,
    #[serde(borrow)]
    pub uri: jacquard_common::types::string::AtUri<'a>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub viewer: std::option::Option<crate::app_bsky::feed::GeneratorViewerState<'a>>,
}

impl jacquard_common::IntoStatic for GeneratorView<'_> {
    type Output = GeneratorView<'static>;
    fn into_static(self) -> Self::Output {
        GeneratorView {
            accepts_interactions: self.accepts_interactions.into_static(),
            avatar: self.avatar.into_static(),
            cid: self.cid.into_static(),
            content_mode: self.content_mode.into_static(),
            creator: self.creator.into_static(),
            description: self.description.into_static(),
            description_facets: self.description_facets.into_static(),
            did: self.did.into_static(),
            display_name: self.display_name.into_static(),
            indexed_at: self.indexed_at.into_static(),
            labels: self.labels.into_static(),
            like_count: self.like_count.into_static(),
            uri: self.uri.into_static(),
            viewer: self.viewer.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct GeneratorViewerState<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub like: std::option::Option<jacquard_common::types::string::AtUri<'a>>,
}

impl jacquard_common::IntoStatic for GeneratorViewerState<'_> {
    type Output = GeneratorViewerState<'static>;
    fn into_static(self) -> Self::Output {
        GeneratorViewerState {
            like: self.like.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct Interaction<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub event: std::option::Option<jacquard_common::CowStr<'a>>,
    ///Context on a feed item that was originally supplied by the feed generator on getFeedSkeleton.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub feed_context: std::option::Option<jacquard_common::CowStr<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub item: std::option::Option<jacquard_common::types::string::AtUri<'a>>,
    ///Unique identifier per request that may be passed back alongside interactions.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub req_id: std::option::Option<jacquard_common::CowStr<'a>>,
}

impl jacquard_common::IntoStatic for Interaction<'_> {
    type Output = Interaction<'static>;
    fn into_static(self) -> Self::Output {
        Interaction {
            event: self.event.into_static(),
            feed_context: self.feed_context.into_static(),
            item: self.item.into_static(),
            req_id: self.req_id.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct NotFoundPost<'a> {
    pub not_found: bool,
    #[serde(borrow)]
    pub uri: jacquard_common::types::string::AtUri<'a>,
}

impl jacquard_common::IntoStatic for NotFoundPost<'_> {
    type Output = NotFoundPost<'static>;
    fn into_static(self) -> Self::Output {
        NotFoundPost {
            not_found: self.not_found.into_static(),
            uri: self.uri.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct PostView<'a> {
    #[serde(borrow)]
    pub author: crate::app_bsky::actor::ProfileViewBasic<'a>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub bookmark_count: std::option::Option<i64>,
    #[serde(borrow)]
    pub cid: jacquard_common::types::string::Cid<'a>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub embed: std::option::Option<PostViewRecordEmbed<'a>>,
    pub indexed_at: jacquard_common::types::string::Datetime,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub labels: std::option::Option<Vec<crate::com_atproto::label::Label<'a>>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub like_count: std::option::Option<i64>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub quote_count: std::option::Option<i64>,
    #[serde(borrow)]
    pub record: jacquard_common::types::value::Data<'a>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reply_count: std::option::Option<i64>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub repost_count: std::option::Option<i64>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub threadgate: std::option::Option<crate::app_bsky::feed::ThreadgateView<'a>>,
    #[serde(borrow)]
    pub uri: jacquard_common::types::string::AtUri<'a>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub viewer: std::option::Option<crate::app_bsky::feed::ViewerState<'a>>,
}

#[jacquard_derive::open_union]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(tag = "$type")]
#[serde(bound(deserialize = "'de: 'a"))]
pub enum PostViewRecordEmbed<'a> {
    #[serde(rename = "app.bsky.embed.images#view")]
    ImagesView(Box<crate::app_bsky::embed::images::View<'a>>),
    #[serde(rename = "app.bsky.embed.video#view")]
    VideoView(Box<crate::app_bsky::embed::video::View<'a>>),
    #[serde(rename = "app.bsky.embed.external#view")]
    ExternalView(Box<crate::app_bsky::embed::external::View<'a>>),
    #[serde(rename = "app.bsky.embed.record#view")]
    RecordView(Box<crate::app_bsky::embed::record::View<'a>>),
    #[serde(rename = "app.bsky.embed.recordWithMedia#view")]
    RecordWithMediaView(Box<crate::app_bsky::embed::record_with_media::View<'a>>),
}

impl jacquard_common::IntoStatic for PostViewRecordEmbed<'_> {
    type Output = PostViewRecordEmbed<'static>;
    fn into_static(self) -> Self::Output {
        match self {
            PostViewRecordEmbed::ImagesView(v) => {
                PostViewRecordEmbed::ImagesView(v.into_static())
            }
            PostViewRecordEmbed::VideoView(v) => {
                PostViewRecordEmbed::VideoView(v.into_static())
            }
            PostViewRecordEmbed::ExternalView(v) => {
                PostViewRecordEmbed::ExternalView(v.into_static())
            }
            PostViewRecordEmbed::RecordView(v) => {
                PostViewRecordEmbed::RecordView(v.into_static())
            }
            PostViewRecordEmbed::RecordWithMediaView(v) => {
                PostViewRecordEmbed::RecordWithMediaView(v.into_static())
            }
            PostViewRecordEmbed::Unknown(v) => {
                PostViewRecordEmbed::Unknown(v.into_static())
            }
        }
    }
}

impl jacquard_common::IntoStatic for PostView<'_> {
    type Output = PostView<'static>;
    fn into_static(self) -> Self::Output {
        PostView {
            author: self.author.into_static(),
            bookmark_count: self.bookmark_count.into_static(),
            cid: self.cid.into_static(),
            embed: self.embed.into_static(),
            indexed_at: self.indexed_at.into_static(),
            labels: self.labels.into_static(),
            like_count: self.like_count.into_static(),
            quote_count: self.quote_count.into_static(),
            record: self.record.into_static(),
            reply_count: self.reply_count.into_static(),
            repost_count: self.repost_count.into_static(),
            threadgate: self.threadgate.into_static(),
            uri: self.uri.into_static(),
            viewer: self.viewer.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct ReasonPin<'a> {}
impl jacquard_common::IntoStatic for ReasonPin<'_> {
    type Output = ReasonPin<'static>;
    fn into_static(self) -> Self::Output {
        ReasonPin {
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct ReasonRepost<'a> {
    #[serde(borrow)]
    pub by: crate::app_bsky::actor::ProfileViewBasic<'a>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub cid: std::option::Option<jacquard_common::types::string::Cid<'a>>,
    pub indexed_at: jacquard_common::types::string::Datetime,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub uri: std::option::Option<jacquard_common::types::string::AtUri<'a>>,
}

impl jacquard_common::IntoStatic for ReasonRepost<'_> {
    type Output = ReasonRepost<'static>;
    fn into_static(self) -> Self::Output {
        ReasonRepost {
            by: self.by.into_static(),
            cid: self.cid.into_static(),
            indexed_at: self.indexed_at.into_static(),
            uri: self.uri.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct ReplyRef<'a> {
    ///When parent is a reply to another post, this is the author of that post.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub grandparent_author: std::option::Option<
        crate::app_bsky::actor::ProfileViewBasic<'a>,
    >,
    #[serde(borrow)]
    pub parent: ReplyRefRecordParent<'a>,
    #[serde(borrow)]
    pub root: ReplyRefRecordRoot<'a>,
}

#[jacquard_derive::open_union]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(tag = "$type")]
#[serde(bound(deserialize = "'de: 'a"))]
pub enum ReplyRefRecordParent<'a> {}
impl jacquard_common::IntoStatic for ReplyRefRecordParent<'_> {
    type Output = ReplyRefRecordParent<'static>;
    fn into_static(self) -> Self::Output {
        match self {
            ReplyRefRecordParent::Unknown(v) => {
                ReplyRefRecordParent::Unknown(v.into_static())
            }
        }
    }
}

#[jacquard_derive::open_union]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(tag = "$type")]
#[serde(bound(deserialize = "'de: 'a"))]
pub enum ReplyRefRecordRoot<'a> {}
impl jacquard_common::IntoStatic for ReplyRefRecordRoot<'_> {
    type Output = ReplyRefRecordRoot<'static>;
    fn into_static(self) -> Self::Output {
        match self {
            ReplyRefRecordRoot::Unknown(v) => {
                ReplyRefRecordRoot::Unknown(v.into_static())
            }
        }
    }
}

impl jacquard_common::IntoStatic for ReplyRef<'_> {
    type Output = ReplyRef<'static>;
    fn into_static(self) -> Self::Output {
        ReplyRef {
            grandparent_author: self.grandparent_author.into_static(),
            parent: self.parent.into_static(),
            root: self.root.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct SkeletonFeedPost<'a> {
    ///Context that will be passed through to client and may be passed to feed generator back alongside interactions.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub feed_context: std::option::Option<jacquard_common::CowStr<'a>>,
    #[serde(borrow)]
    pub post: jacquard_common::types::string::AtUri<'a>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub reason: std::option::Option<SkeletonFeedPostRecordReason<'a>>,
}

#[jacquard_derive::open_union]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(tag = "$type")]
#[serde(bound(deserialize = "'de: 'a"))]
pub enum SkeletonFeedPostRecordReason<'a> {}
impl jacquard_common::IntoStatic for SkeletonFeedPostRecordReason<'_> {
    type Output = SkeletonFeedPostRecordReason<'static>;
    fn into_static(self) -> Self::Output {
        match self {
            SkeletonFeedPostRecordReason::Unknown(v) => {
                SkeletonFeedPostRecordReason::Unknown(v.into_static())
            }
        }
    }
}

impl jacquard_common::IntoStatic for SkeletonFeedPost<'_> {
    type Output = SkeletonFeedPost<'static>;
    fn into_static(self) -> Self::Output {
        SkeletonFeedPost {
            feed_context: self.feed_context.into_static(),
            post: self.post.into_static(),
            reason: self.reason.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct SkeletonReasonPin<'a> {}
impl jacquard_common::IntoStatic for SkeletonReasonPin<'_> {
    type Output = SkeletonReasonPin<'static>;
    fn into_static(self) -> Self::Output {
        SkeletonReasonPin {
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct SkeletonReasonRepost<'a> {
    #[serde(borrow)]
    pub repost: jacquard_common::types::string::AtUri<'a>,
}

impl jacquard_common::IntoStatic for SkeletonReasonRepost<'_> {
    type Output = SkeletonReasonRepost<'static>;
    fn into_static(self) -> Self::Output {
        SkeletonReasonRepost {
            repost: self.repost.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

///Metadata about this post within the context of the thread it is in.
#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct ThreadContext<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub root_author_like: std::option::Option<jacquard_common::types::string::AtUri<'a>>,
}

impl jacquard_common::IntoStatic for ThreadContext<'_> {
    type Output = ThreadContext<'static>;
    fn into_static(self) -> Self::Output {
        ThreadContext {
            root_author_like: self.root_author_like.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct ThreadViewPost<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub parent: std::option::Option<ThreadViewPostRecordParent<'a>>,
    #[serde(borrow)]
    pub post: crate::app_bsky::feed::PostView<'a>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub replies: std::option::Option<Vec<jacquard_common::types::value::Data<'a>>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub thread_context: std::option::Option<crate::app_bsky::feed::ThreadContext<'a>>,
}

#[jacquard_derive::open_union]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(tag = "$type")]
#[serde(bound(deserialize = "'de: 'a"))]
pub enum ThreadViewPostRecordParent<'a> {}
impl jacquard_common::IntoStatic for ThreadViewPostRecordParent<'_> {
    type Output = ThreadViewPostRecordParent<'static>;
    fn into_static(self) -> Self::Output {
        match self {
            ThreadViewPostRecordParent::Unknown(v) => {
                ThreadViewPostRecordParent::Unknown(v.into_static())
            }
        }
    }
}

impl jacquard_common::IntoStatic for ThreadViewPost<'_> {
    type Output = ThreadViewPost<'static>;
    fn into_static(self) -> Self::Output {
        ThreadViewPost {
            parent: self.parent.into_static(),
            post: self.post.into_static(),
            replies: self.replies.into_static(),
            thread_context: self.thread_context.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct ThreadgateView<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub cid: std::option::Option<jacquard_common::types::string::Cid<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub lists: std::option::Option<Vec<crate::app_bsky::graph::ListViewBasic<'a>>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub record: std::option::Option<jacquard_common::types::value::Data<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub uri: std::option::Option<jacquard_common::types::string::AtUri<'a>>,
}

impl jacquard_common::IntoStatic for ThreadgateView<'_> {
    type Output = ThreadgateView<'static>;
    fn into_static(self) -> Self::Output {
        ThreadgateView {
            cid: self.cid.into_static(),
            lists: self.lists.into_static(),
            record: self.record.into_static(),
            uri: self.uri.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

///Metadata about the requesting account's relationship with the subject content. Only has meaningful content for authed requests.
#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct ViewerState<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub bookmarked: std::option::Option<bool>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub embedding_disabled: std::option::Option<bool>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub like: std::option::Option<jacquard_common::types::string::AtUri<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub pinned: std::option::Option<bool>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reply_disabled: std::option::Option<bool>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub repost: std::option::Option<jacquard_common::types::string::AtUri<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub thread_muted: std::option::Option<bool>,
}

impl jacquard_common::IntoStatic for ViewerState<'_> {
    type Output = ViewerState<'static>;
    fn into_static(self) -> Self::Output {
        ViewerState {
            bookmarked: self.bookmarked.into_static(),
            embedding_disabled: self.embedding_disabled.into_static(),
            like: self.like.into_static(),
            pinned: self.pinned.into_static(),
            reply_disabled: self.reply_disabled.into_static(),
            repost: self.repost.into_static(),
            thread_muted: self.thread_muted.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}