// @generated by jacquard-lexicon. DO NOT EDIT.
//
// Lexicon: app.bsky.actor.defs
//
// This file was automatically generated from Lexicon schemas.
// Any manual changes will be overwritten on the next regeneration.

pub mod get_preferences;
pub mod get_profile;
pub mod get_profiles;
pub mod get_suggestions;
pub mod profile;
pub mod put_preferences;
pub mod search_actors;
pub mod search_actors_typeahead;
pub mod status;

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct AdultContentPref<'a> {
    pub enabled: bool,
}

impl jacquard_common::IntoStatic for AdultContentPref<'_> {
    type Output = AdultContentPref<'static>;
    fn into_static(self) -> Self::Output {
        AdultContentPref {
            enabled: self.enabled.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

///If set, an active progress guide. Once completed, can be set to undefined. Should have unspecced fields tracking progress.
#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct BskyAppProgressGuide<'a> {
    #[serde(borrow)]
    pub guide: jacquard_common::CowStr<'a>,
}

impl jacquard_common::IntoStatic for BskyAppProgressGuide<'_> {
    type Output = BskyAppProgressGuide<'static>;
    fn into_static(self) -> Self::Output {
        BskyAppProgressGuide {
            guide: self.guide.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

///A grab bag of state that's specific to the bsky.app program. Third-party apps shouldn't use this.
#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct BskyAppStatePref<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub active_progress_guide: std::option::Option<
        crate::app_bsky::actor::BskyAppProgressGuide<'a>,
    >,
    ///Storage for NUXs the user has encountered.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub nuxs: std::option::Option<Vec<crate::app_bsky::actor::Nux<'a>>>,
    ///An array of tokens which identify nudges (modals, popups, tours, highlight dots) that should be shown to the user.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub queued_nudges: std::option::Option<Vec<jacquard_common::CowStr<'a>>>,
}

impl jacquard_common::IntoStatic for BskyAppStatePref<'_> {
    type Output = BskyAppStatePref<'static>;
    fn into_static(self) -> Self::Output {
        BskyAppStatePref {
            active_progress_guide: self.active_progress_guide.into_static(),
            nuxs: self.nuxs.into_static(),
            queued_nudges: self.queued_nudges.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct ContentLabelPref<'a> {
    #[serde(borrow)]
    pub label: jacquard_common::CowStr<'a>,
    ///Which labeler does this preference apply to? If undefined, applies globally.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub labeler_did: std::option::Option<jacquard_common::types::string::Did<'a>>,
    #[serde(borrow)]
    pub visibility: jacquard_common::CowStr<'a>,
}

impl jacquard_common::IntoStatic for ContentLabelPref<'_> {
    type Output = ContentLabelPref<'static>;
    fn into_static(self) -> Self::Output {
        ContentLabelPref {
            label: self.label.into_static(),
            labeler_did: self.labeler_did.into_static(),
            visibility: self.visibility.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct FeedViewPref<'a> {
    ///The URI of the feed, or an identifier which describes the feed.
    #[serde(borrow)]
    pub feed: jacquard_common::CowStr<'a>,
    ///Hide quote posts in the feed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub hide_quote_posts: std::option::Option<bool>,
    ///Hide replies in the feed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub hide_replies: std::option::Option<bool>,
    ///Hide replies in the feed if they do not have this number of likes.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub hide_replies_by_like_count: std::option::Option<i64>,
    ///Hide replies in the feed if they are not by followed users.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub hide_replies_by_unfollowed: std::option::Option<bool>,
    ///Hide reposts in the feed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub hide_reposts: std::option::Option<bool>,
}

impl jacquard_common::IntoStatic for FeedViewPref<'_> {
    type Output = FeedViewPref<'static>;
    fn into_static(self) -> Self::Output {
        FeedViewPref {
            feed: self.feed.into_static(),
            hide_quote_posts: self.hide_quote_posts.into_static(),
            hide_replies: self.hide_replies.into_static(),
            hide_replies_by_like_count: self.hide_replies_by_like_count.into_static(),
            hide_replies_by_unfollowed: self.hide_replies_by_unfollowed.into_static(),
            hide_reposts: self.hide_reposts.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct HiddenPostsPref<'a> {
    ///A list of URIs of posts the account owner has hidden.
    #[serde(borrow)]
    pub items: Vec<jacquard_common::types::string::AtUri<'a>>,
}

impl jacquard_common::IntoStatic for HiddenPostsPref<'_> {
    type Output = HiddenPostsPref<'static>;
    fn into_static(self) -> Self::Output {
        HiddenPostsPref {
            items: self.items.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct InterestsPref<'a> {
    ///A list of tags which describe the account owner's interests gathered during onboarding.
    #[serde(borrow)]
    pub tags: Vec<jacquard_common::CowStr<'a>>,
}

impl jacquard_common::IntoStatic for InterestsPref<'_> {
    type Output = InterestsPref<'static>;
    fn into_static(self) -> Self::Output {
        InterestsPref {
            tags: self.tags.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

///The subject's followers whom you also follow
#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct KnownFollowers<'a> {
    pub count: i64,
    #[serde(borrow)]
    pub followers: Vec<crate::app_bsky::actor::ProfileViewBasic<'a>>,
}

impl jacquard_common::IntoStatic for KnownFollowers<'_> {
    type Output = KnownFollowers<'static>;
    fn into_static(self) -> Self::Output {
        KnownFollowers {
            count: self.count.into_static(),
            followers: self.followers.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct LabelerPrefItem<'a> {
    #[serde(borrow)]
    pub did: jacquard_common::types::string::Did<'a>,
}

impl jacquard_common::IntoStatic for LabelerPrefItem<'_> {
    type Output = LabelerPrefItem<'static>;
    fn into_static(self) -> Self::Output {
        LabelerPrefItem {
            did: self.did.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct LabelersPref<'a> {
    #[serde(borrow)]
    pub labelers: Vec<crate::app_bsky::actor::LabelerPrefItem<'a>>,
}

impl jacquard_common::IntoStatic for LabelersPref<'_> {
    type Output = LabelersPref<'static>;
    fn into_static(self) -> Self::Output {
        LabelersPref {
            labelers: self.labelers.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

///A word that the account owner has muted.
#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct MutedWord<'a> {
    ///Groups of users to apply the muted word to. If undefined, applies to all users.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub actor_target: std::option::Option<jacquard_common::CowStr<'a>>,
    ///The date and time at which the muted word will expire and no longer be applied.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expires_at: std::option::Option<jacquard_common::types::string::Datetime>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub id: std::option::Option<jacquard_common::CowStr<'a>>,
    ///The intended targets of the muted word.
    #[serde(borrow)]
    pub targets: Vec<crate::app_bsky::actor::MutedWordTarget<'a>>,
    ///The muted word itself.
    #[serde(borrow)]
    pub value: jacquard_common::CowStr<'a>,
}

impl jacquard_common::IntoStatic for MutedWord<'_> {
    type Output = MutedWord<'static>;
    fn into_static(self) -> Self::Output {
        MutedWord {
            actor_target: self.actor_target.into_static(),
            expires_at: self.expires_at.into_static(),
            id: self.id.into_static(),
            targets: self.targets.into_static(),
            value: self.value.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum MutedWordTarget<'a> {
    Content,
    Tag,
    Other(jacquard_common::CowStr<'a>),
}

impl<'a> MutedWordTarget<'a> {
    pub fn as_str(&self) -> &str {
        match self {
            Self::Content => "content",
            Self::Tag => "tag",
            Self::Other(s) => s.as_ref(),
        }
    }
}

impl<'a> From<&'a str> for MutedWordTarget<'a> {
    fn from(s: &'a str) -> Self {
        match s {
            "content" => Self::Content,
            "tag" => Self::Tag,
            _ => Self::Other(jacquard_common::CowStr::from(s)),
        }
    }
}

impl<'a> From<String> for MutedWordTarget<'a> {
    fn from(s: String) -> Self {
        match s.as_str() {
            "content" => Self::Content,
            "tag" => Self::Tag,
            _ => Self::Other(jacquard_common::CowStr::from(s)),
        }
    }
}

impl<'a> AsRef<str> for MutedWordTarget<'a> {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

impl<'a> serde::Serialize for MutedWordTarget<'a> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(self.as_str())
    }
}

impl<'de, 'a> serde::Deserialize<'de> for MutedWordTarget<'a>
where
    'de: 'a,
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let s = <&'de str>::deserialize(deserializer)?;
        Ok(Self::from(s))
    }
}

impl jacquard_common::IntoStatic for MutedWordTarget<'_> {
    type Output = MutedWordTarget<'static>;
    fn into_static(self) -> Self::Output {
        match self {
            MutedWordTarget::Content => MutedWordTarget::Content,
            MutedWordTarget::Tag => MutedWordTarget::Tag,
            MutedWordTarget::Other(v) => MutedWordTarget::Other(v.into_static()),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct MutedWordsPref<'a> {
    ///A list of words the account owner has muted.
    #[serde(borrow)]
    pub items: Vec<crate::app_bsky::actor::MutedWord<'a>>,
}

impl jacquard_common::IntoStatic for MutedWordsPref<'_> {
    type Output = MutedWordsPref<'static>;
    fn into_static(self) -> Self::Output {
        MutedWordsPref {
            items: self.items.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

///A new user experiences (NUX) storage object
#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct Nux<'a> {
    pub completed: bool,
    ///Arbitrary data for the NUX. The structure is defined by the NUX itself. Limited to 300 characters.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub data: std::option::Option<jacquard_common::CowStr<'a>>,
    ///The date and time at which the NUX will expire and should be considered completed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expires_at: std::option::Option<jacquard_common::types::string::Datetime>,
    #[serde(borrow)]
    pub id: jacquard_common::CowStr<'a>,
}

impl jacquard_common::IntoStatic for Nux<'_> {
    type Output = Nux<'static>;
    fn into_static(self) -> Self::Output {
        Nux {
            completed: self.completed.into_static(),
            data: self.data.into_static(),
            expires_at: self.expires_at.into_static(),
            id: self.id.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct PersonalDetailsPref<'a> {
    ///The birth date of account owner.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub birth_date: std::option::Option<jacquard_common::types::string::Datetime>,
}

impl jacquard_common::IntoStatic for PersonalDetailsPref<'_> {
    type Output = PersonalDetailsPref<'static>;
    fn into_static(self) -> Self::Output {
        PersonalDetailsPref {
            birth_date: self.birth_date.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

///Default post interaction settings for the account. These values should be applied as default values when creating new posts. These refs should mirror the threadgate and postgate records exactly.
#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct PostInteractionSettingsPref<'a> {
    ///Matches postgate record. List of rules defining who can embed this users posts. If value is an empty array or is undefined, no particular rules apply and anyone can embed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub postgate_embedding_rules: std::option::Option<
        Vec<jacquard_common::types::value::Data<'a>>,
    >,
    ///Matches threadgate record. List of rules defining who can reply to this users posts. If value is an empty array, no one can reply. If value is undefined, anyone can reply.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub threadgate_allow_rules: std::option::Option<
        Vec<jacquard_common::types::value::Data<'a>>,
    >,
}

impl jacquard_common::IntoStatic for PostInteractionSettingsPref<'_> {
    type Output = PostInteractionSettingsPref<'static>;
    fn into_static(self) -> Self::Output {
        PostInteractionSettingsPref {
            postgate_embedding_rules: self.postgate_embedding_rules.into_static(),
            threadgate_allow_rules: self.threadgate_allow_rules.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

pub type Preferences<'a> = Vec<jacquard_common::types::value::Data<'a>>;
#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct ProfileAssociated<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub activity_subscription: std::option::Option<
        crate::app_bsky::actor::ProfileAssociatedActivitySubscription<'a>,
    >,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub chat: std::option::Option<crate::app_bsky::actor::ProfileAssociatedChat<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub feedgens: std::option::Option<i64>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub labeler: std::option::Option<bool>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub lists: std::option::Option<i64>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub starter_packs: std::option::Option<i64>,
}

impl jacquard_common::IntoStatic for ProfileAssociated<'_> {
    type Output = ProfileAssociated<'static>;
    fn into_static(self) -> Self::Output {
        ProfileAssociated {
            activity_subscription: self.activity_subscription.into_static(),
            chat: self.chat.into_static(),
            feedgens: self.feedgens.into_static(),
            labeler: self.labeler.into_static(),
            lists: self.lists.into_static(),
            starter_packs: self.starter_packs.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct ProfileAssociatedActivitySubscription<'a> {
    #[serde(borrow)]
    pub allow_subscriptions: jacquard_common::CowStr<'a>,
}

impl jacquard_common::IntoStatic for ProfileAssociatedActivitySubscription<'_> {
    type Output = ProfileAssociatedActivitySubscription<'static>;
    fn into_static(self) -> Self::Output {
        ProfileAssociatedActivitySubscription {
            allow_subscriptions: self.allow_subscriptions.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct ProfileAssociatedChat<'a> {
    #[serde(borrow)]
    pub allow_incoming: jacquard_common::CowStr<'a>,
}

impl jacquard_common::IntoStatic for ProfileAssociatedChat<'_> {
    type Output = ProfileAssociatedChat<'static>;
    fn into_static(self) -> Self::Output {
        ProfileAssociatedChat {
            allow_incoming: self.allow_incoming.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct ProfileView<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub associated: std::option::Option<crate::app_bsky::actor::ProfileAssociated<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub avatar: std::option::Option<jacquard_common::types::string::Uri<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub created_at: std::option::Option<jacquard_common::types::string::Datetime>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub description: std::option::Option<jacquard_common::CowStr<'a>>,
    #[serde(borrow)]
    pub did: jacquard_common::types::string::Did<'a>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub display_name: std::option::Option<jacquard_common::CowStr<'a>>,
    #[serde(borrow)]
    pub handle: jacquard_common::types::string::Handle<'a>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub indexed_at: std::option::Option<jacquard_common::types::string::Datetime>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub labels: std::option::Option<Vec<crate::com_atproto::label::Label<'a>>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub pronouns: std::option::Option<jacquard_common::CowStr<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub status: std::option::Option<crate::app_bsky::actor::StatusView<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub verification: std::option::Option<crate::app_bsky::actor::VerificationState<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub viewer: std::option::Option<crate::app_bsky::actor::ViewerState<'a>>,
}

impl jacquard_common::IntoStatic for ProfileView<'_> {
    type Output = ProfileView<'static>;
    fn into_static(self) -> Self::Output {
        ProfileView {
            associated: self.associated.into_static(),
            avatar: self.avatar.into_static(),
            created_at: self.created_at.into_static(),
            description: self.description.into_static(),
            did: self.did.into_static(),
            display_name: self.display_name.into_static(),
            handle: self.handle.into_static(),
            indexed_at: self.indexed_at.into_static(),
            labels: self.labels.into_static(),
            pronouns: self.pronouns.into_static(),
            status: self.status.into_static(),
            verification: self.verification.into_static(),
            viewer: self.viewer.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct ProfileViewBasic<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub associated: std::option::Option<crate::app_bsky::actor::ProfileAssociated<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub avatar: std::option::Option<jacquard_common::types::string::Uri<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub created_at: std::option::Option<jacquard_common::types::string::Datetime>,
    #[serde(borrow)]
    pub did: jacquard_common::types::string::Did<'a>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub display_name: std::option::Option<jacquard_common::CowStr<'a>>,
    #[serde(borrow)]
    pub handle: jacquard_common::types::string::Handle<'a>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub labels: std::option::Option<Vec<crate::com_atproto::label::Label<'a>>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub pronouns: std::option::Option<jacquard_common::CowStr<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub status: std::option::Option<crate::app_bsky::actor::StatusView<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub verification: std::option::Option<crate::app_bsky::actor::VerificationState<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub viewer: std::option::Option<crate::app_bsky::actor::ViewerState<'a>>,
}

impl jacquard_common::IntoStatic for ProfileViewBasic<'_> {
    type Output = ProfileViewBasic<'static>;
    fn into_static(self) -> Self::Output {
        ProfileViewBasic {
            associated: self.associated.into_static(),
            avatar: self.avatar.into_static(),
            created_at: self.created_at.into_static(),
            did: self.did.into_static(),
            display_name: self.display_name.into_static(),
            handle: self.handle.into_static(),
            labels: self.labels.into_static(),
            pronouns: self.pronouns.into_static(),
            status: self.status.into_static(),
            verification: self.verification.into_static(),
            viewer: self.viewer.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct ProfileViewDetailed<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub associated: std::option::Option<crate::app_bsky::actor::ProfileAssociated<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub avatar: std::option::Option<jacquard_common::types::string::Uri<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub banner: std::option::Option<jacquard_common::types::string::Uri<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub created_at: std::option::Option<jacquard_common::types::string::Datetime>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub description: std::option::Option<jacquard_common::CowStr<'a>>,
    #[serde(borrow)]
    pub did: jacquard_common::types::string::Did<'a>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub display_name: std::option::Option<jacquard_common::CowStr<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub followers_count: std::option::Option<i64>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub follows_count: std::option::Option<i64>,
    #[serde(borrow)]
    pub handle: jacquard_common::types::string::Handle<'a>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub indexed_at: std::option::Option<jacquard_common::types::string::Datetime>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub joined_via_starter_pack: std::option::Option<
        crate::app_bsky::graph::StarterPackViewBasic<'a>,
    >,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub labels: std::option::Option<Vec<crate::com_atproto::label::Label<'a>>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub pinned_post: std::option::Option<
        crate::com_atproto::repo::strong_ref::StrongRef<'a>,
    >,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub posts_count: std::option::Option<i64>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub pronouns: std::option::Option<jacquard_common::CowStr<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub status: std::option::Option<crate::app_bsky::actor::StatusView<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub verification: std::option::Option<crate::app_bsky::actor::VerificationState<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub viewer: std::option::Option<crate::app_bsky::actor::ViewerState<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub website: std::option::Option<jacquard_common::types::string::Uri<'a>>,
}

impl jacquard_common::IntoStatic for ProfileViewDetailed<'_> {
    type Output = ProfileViewDetailed<'static>;
    fn into_static(self) -> Self::Output {
        ProfileViewDetailed {
            associated: self.associated.into_static(),
            avatar: self.avatar.into_static(),
            banner: self.banner.into_static(),
            created_at: self.created_at.into_static(),
            description: self.description.into_static(),
            did: self.did.into_static(),
            display_name: self.display_name.into_static(),
            followers_count: self.followers_count.into_static(),
            follows_count: self.follows_count.into_static(),
            handle: self.handle.into_static(),
            indexed_at: self.indexed_at.into_static(),
            joined_via_starter_pack: self.joined_via_starter_pack.into_static(),
            labels: self.labels.into_static(),
            pinned_post: self.pinned_post.into_static(),
            posts_count: self.posts_count.into_static(),
            pronouns: self.pronouns.into_static(),
            status: self.status.into_static(),
            verification: self.verification.into_static(),
            viewer: self.viewer.into_static(),
            website: self.website.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct SavedFeed<'a> {
    #[serde(borrow)]
    pub id: jacquard_common::CowStr<'a>,
    pub pinned: bool,
    #[serde(borrow)]
    pub r#type: jacquard_common::CowStr<'a>,
    #[serde(borrow)]
    pub value: jacquard_common::CowStr<'a>,
}

impl jacquard_common::IntoStatic for SavedFeed<'_> {
    type Output = SavedFeed<'static>;
    fn into_static(self) -> Self::Output {
        SavedFeed {
            id: self.id.into_static(),
            pinned: self.pinned.into_static(),
            r#type: self.r#type.into_static(),
            value: self.value.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct SavedFeedsPref<'a> {
    #[serde(borrow)]
    pub pinned: Vec<jacquard_common::types::string::AtUri<'a>>,
    #[serde(borrow)]
    pub saved: Vec<jacquard_common::types::string::AtUri<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub timeline_index: std::option::Option<i64>,
}

impl jacquard_common::IntoStatic for SavedFeedsPref<'_> {
    type Output = SavedFeedsPref<'static>;
    fn into_static(self) -> Self::Output {
        SavedFeedsPref {
            pinned: self.pinned.into_static(),
            saved: self.saved.into_static(),
            timeline_index: self.timeline_index.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct SavedFeedsPrefV2<'a> {
    #[serde(borrow)]
    pub items: Vec<crate::app_bsky::actor::SavedFeed<'a>>,
}

impl jacquard_common::IntoStatic for SavedFeedsPrefV2<'_> {
    type Output = SavedFeedsPrefV2<'static>;
    fn into_static(self) -> Self::Output {
        SavedFeedsPrefV2 {
            items: self.items.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct StatusView<'a> {
    ///An optional embed associated with the status.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub embed: std::option::Option<StatusViewRecordEmbed<'a>>,
    ///The date when this status will expire. The application might choose to no longer return the status after expiration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expires_at: std::option::Option<jacquard_common::types::string::Datetime>,
    ///True if the status is not expired, false if it is expired. Only present if expiration was set.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub is_active: std::option::Option<bool>,
    #[serde(borrow)]
    pub record: jacquard_common::types::value::Data<'a>,
    ///The status for the account.
    #[serde(borrow)]
    pub status: jacquard_common::CowStr<'a>,
}

#[jacquard_derive::open_union]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(tag = "$type")]
#[serde(bound(deserialize = "'de: 'a"))]
pub enum StatusViewRecordEmbed<'a> {
    #[serde(rename = "app.bsky.embed.external#view")]
    ExternalView(Box<crate::app_bsky::embed::external::View<'a>>),
}

impl jacquard_common::IntoStatic for StatusViewRecordEmbed<'_> {
    type Output = StatusViewRecordEmbed<'static>;
    fn into_static(self) -> Self::Output {
        match self {
            StatusViewRecordEmbed::ExternalView(v) => {
                StatusViewRecordEmbed::ExternalView(v.into_static())
            }
            StatusViewRecordEmbed::Unknown(v) => {
                StatusViewRecordEmbed::Unknown(v.into_static())
            }
        }
    }
}

impl jacquard_common::IntoStatic for StatusView<'_> {
    type Output = StatusView<'static>;
    fn into_static(self) -> Self::Output {
        StatusView {
            embed: self.embed.into_static(),
            expires_at: self.expires_at.into_static(),
            is_active: self.is_active.into_static(),
            record: self.record.into_static(),
            status: self.status.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct ThreadViewPref<'a> {
    ///Show followed users at the top of all replies.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prioritize_followed_users: std::option::Option<bool>,
    ///Sorting mode for threads.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub sort: std::option::Option<jacquard_common::CowStr<'a>>,
}

impl jacquard_common::IntoStatic for ThreadViewPref<'_> {
    type Output = ThreadViewPref<'static>;
    fn into_static(self) -> Self::Output {
        ThreadViewPref {
            prioritize_followed_users: self.prioritize_followed_users.into_static(),
            sort: self.sort.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

///Preferences for how verified accounts appear in the app.
#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct VerificationPrefs<'a> {
    ///Hide the blue check badges for verified accounts and trusted verifiers.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub hide_badges: std::option::Option<bool>,
}

impl jacquard_common::IntoStatic for VerificationPrefs<'_> {
    type Output = VerificationPrefs<'static>;
    fn into_static(self) -> Self::Output {
        VerificationPrefs {
            hide_badges: self.hide_badges.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

///Represents the verification information about the user this object is attached to.
#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct VerificationState<'a> {
    ///The user's status as a trusted verifier.
    #[serde(borrow)]
    pub trusted_verifier_status: jacquard_common::CowStr<'a>,
    ///All verifications issued by trusted verifiers on behalf of this user. Verifications by untrusted verifiers are not included.
    #[serde(borrow)]
    pub verifications: Vec<crate::app_bsky::actor::VerificationView<'a>>,
    ///The user's status as a verified account.
    #[serde(borrow)]
    pub verified_status: jacquard_common::CowStr<'a>,
}

impl jacquard_common::IntoStatic for VerificationState<'_> {
    type Output = VerificationState<'static>;
    fn into_static(self) -> Self::Output {
        VerificationState {
            trusted_verifier_status: self.trusted_verifier_status.into_static(),
            verifications: self.verifications.into_static(),
            verified_status: self.verified_status.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

///An individual verification for an associated subject.
#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct VerificationView<'a> {
    ///Timestamp when the verification was created.
    pub created_at: jacquard_common::types::string::Datetime,
    ///True if the verification passes validation, otherwise false.
    pub is_valid: bool,
    ///The user who issued this verification.
    #[serde(borrow)]
    pub issuer: jacquard_common::types::string::Did<'a>,
    ///The AT-URI of the verification record.
    #[serde(borrow)]
    pub uri: jacquard_common::types::string::AtUri<'a>,
}

impl jacquard_common::IntoStatic for VerificationView<'_> {
    type Output = VerificationView<'static>;
    fn into_static(self) -> Self::Output {
        VerificationView {
            created_at: self.created_at.into_static(),
            is_valid: self.is_valid.into_static(),
            issuer: self.issuer.into_static(),
            uri: self.uri.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

///Metadata about the requesting account's relationship with the subject account. Only has meaningful content for authed requests.
#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct ViewerState<'a> {
    ///This property is present only in selected cases, as an optimization.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub activity_subscription: std::option::Option<
        crate::app_bsky::notification::ActivitySubscription<'a>,
    >,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub blocked_by: std::option::Option<bool>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub blocking: std::option::Option<jacquard_common::types::string::AtUri<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub blocking_by_list: std::option::Option<crate::app_bsky::graph::ListViewBasic<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub followed_by: std::option::Option<jacquard_common::types::string::AtUri<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub following: std::option::Option<jacquard_common::types::string::AtUri<'a>>,
    ///This property is present only in selected cases, as an optimization.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub known_followers: std::option::Option<crate::app_bsky::actor::KnownFollowers<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub muted: std::option::Option<bool>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub muted_by_list: std::option::Option<crate::app_bsky::graph::ListViewBasic<'a>>,
}

impl jacquard_common::IntoStatic for ViewerState<'_> {
    type Output = ViewerState<'static>;
    fn into_static(self) -> Self::Output {
        ViewerState {
            activity_subscription: self.activity_subscription.into_static(),
            blocked_by: self.blocked_by.into_static(),
            blocking: self.blocking.into_static(),
            blocking_by_list: self.blocking_by_list.into_static(),
            followed_by: self.followed_by.into_static(),
            following: self.following.into_static(),
            known_followers: self.known_followers.into_static(),
            muted: self.muted.into_static(),
            muted_by_list: self.muted_by_list.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}