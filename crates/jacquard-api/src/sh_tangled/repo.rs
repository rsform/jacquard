// @generated by jacquard-lexicon. DO NOT EDIT.
//
// Lexicon: sh.tangled.repo
//
// This file was automatically generated from Lexicon schemas.
// Any manual changes will be overwritten on the next regeneration.

pub mod add_secret;
pub mod archive;
pub mod artifact;
pub mod blob;
pub mod branch;
pub mod branches;
pub mod collaborator;
pub mod compare;
pub mod create;
pub mod delete;
pub mod delete_branch;
pub mod diff;
pub mod fork_status;
pub mod fork_sync;
pub mod get_default_branch;
pub mod hidden_ref;
pub mod issue;
pub mod languages;
pub mod list_secrets;
pub mod log;
pub mod merge;
pub mod merge_check;
pub mod pull;
pub mod remove_secret;
pub mod set_default_branch;
pub mod tags;
pub mod tree;

#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic,
    bon::Builder
)]
#[serde(rename_all = "camelCase")]
pub struct Repo<'a> {
    pub created_at: jacquard_common::types::string::Datetime,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    #[serde(borrow)]
    pub description: Option<jacquard_common::CowStr<'a>>,
    /// knot where the repo was created
    #[serde(borrow)]
    #[builder(into)]
    pub knot: jacquard_common::CowStr<'a>,
    /// List of labels that this repo subscribes to
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    #[serde(borrow)]
    pub labels: Option<Vec<jacquard_common::types::string::AtUri<'a>>>,
    /// name of the repo
    #[serde(borrow)]
    #[builder(into)]
    pub name: jacquard_common::CowStr<'a>,
    /// source of the repo
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    #[serde(borrow)]
    pub source: Option<jacquard_common::types::string::Uri<'a>>,
    /// CI runner to send jobs to and receive results from
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[builder(into)]
    #[serde(borrow)]
    pub spindle: Option<jacquard_common::CowStr<'a>>,
}

impl<'a> Repo<'a> {
    pub fn uri(
        uri: impl Into<jacquard_common::CowStr<'a>>,
    ) -> Result<
        jacquard_common::types::uri::RecordUri<'a, RepoRecord>,
        jacquard_common::types::uri::UriError,
    > {
        jacquard_common::types::uri::RecordUri::try_from_uri(
            jacquard_common::types::string::AtUri::new_cow(uri.into())?,
        )
    }
}

/// Typed wrapper for GetRecord response with this collection's record type.
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic
)]
#[serde(rename_all = "camelCase")]
pub struct RepoGetRecordOutput<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub cid: std::option::Option<jacquard_common::types::string::Cid<'a>>,
    #[serde(borrow)]
    pub uri: jacquard_common::types::string::AtUri<'a>,
    #[serde(borrow)]
    pub value: Repo<'a>,
}

impl From<RepoGetRecordOutput<'_>> for Repo<'_> {
    fn from(output: RepoGetRecordOutput<'_>) -> Self {
        use jacquard_common::IntoStatic;
        output.value.into_static()
    }
}

impl jacquard_common::types::collection::Collection for Repo<'_> {
    const NSID: &'static str = "sh.tangled.repo";
    type Record = RepoRecord;
}

/// Marker type for deserializing records from this collection.
#[derive(Debug, serde::Serialize, serde::Deserialize)]
pub struct RepoRecord;
impl jacquard_common::xrpc::XrpcResp for RepoRecord {
    const NSID: &'static str = "sh.tangled.repo";
    const ENCODING: &'static str = "application/json";
    type Output<'de> = RepoGetRecordOutput<'de>;
    type Err<'de> = jacquard_common::types::collection::RecordError<'de>;
}

impl jacquard_common::types::collection::Collection for RepoRecord {
    const NSID: &'static str = "sh.tangled.repo";
    type Record = RepoRecord;
}