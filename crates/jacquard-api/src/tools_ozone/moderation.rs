// @generated by jacquard-lexicon. DO NOT EDIT.
//
// Lexicon: tools.ozone.moderation.defs
//
// This file was automatically generated from Lexicon schemas.
// Any manual changes will be overwritten on the next regeneration.

pub mod emit_event;
pub mod get_account_timeline;
pub mod get_event;
pub mod get_record;
pub mod get_records;
pub mod get_repo;
pub mod get_reporter_stats;
pub mod get_repos;
pub mod get_subjects;
pub mod query_events;
pub mod query_statuses;
pub mod search_repos;

///Logs account status related events on a repo subject. Normally captured by automod from the firehose and emitted to ozone for historical tracking.
#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct AccountEvent<'a> {
    ///Indicates that the account has a repository which can be fetched from the host that emitted this event.
    pub active: bool,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub comment: std::option::Option<jacquard_common::CowStr<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub status: std::option::Option<jacquard_common::CowStr<'a>>,
    pub timestamp: jacquard_common::types::string::Datetime,
}

impl jacquard_common::IntoStatic for AccountEvent<'_> {
    type Output = AccountEvent<'static>;
    fn into_static(self) -> Self::Output {
        AccountEvent {
            active: self.active.into_static(),
            comment: self.comment.into_static(),
            status: self.status.into_static(),
            timestamp: self.timestamp.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct AccountHosting<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub created_at: std::option::Option<jacquard_common::types::string::Datetime>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deactivated_at: std::option::Option<jacquard_common::types::string::Datetime>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deleted_at: std::option::Option<jacquard_common::types::string::Datetime>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reactivated_at: std::option::Option<jacquard_common::types::string::Datetime>,
    #[serde(borrow)]
    pub status: jacquard_common::CowStr<'a>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub updated_at: std::option::Option<jacquard_common::types::string::Datetime>,
}

impl jacquard_common::IntoStatic for AccountHosting<'_> {
    type Output = AccountHosting<'static>;
    fn into_static(self) -> Self::Output {
        AccountHosting {
            created_at: self.created_at.into_static(),
            deactivated_at: self.deactivated_at.into_static(),
            deleted_at: self.deleted_at.into_static(),
            reactivated_at: self.reactivated_at.into_static(),
            status: self.status.into_static(),
            updated_at: self.updated_at.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

///Statistics about a particular account subject
#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct AccountStats<'a> {
    ///Total number of appeals against a moderation action on the account
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub appeal_count: std::option::Option<i64>,
    ///Number of times the account was escalated
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub escalate_count: std::option::Option<i64>,
    ///Total number of reports on the account
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub report_count: std::option::Option<i64>,
    ///Number of times the account was suspended
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub suspend_count: std::option::Option<i64>,
    ///Number of times the account was taken down
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub takedown_count: std::option::Option<i64>,
}

impl jacquard_common::IntoStatic for AccountStats<'_> {
    type Output = AccountStats<'static>;
    fn into_static(self) -> Self::Output {
        AccountStats {
            appeal_count: self.appeal_count.into_static(),
            escalate_count: self.escalate_count.into_static(),
            report_count: self.report_count.into_static(),
            suspend_count: self.suspend_count.into_static(),
            takedown_count: self.takedown_count.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

///Age assurance info coming directly from users. Only works on DID subjects.
#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct AgeAssuranceEvent<'a> {
    ///The unique identifier for this instance of the age assurance flow, in UUID format.
    #[serde(borrow)]
    pub attempt_id: jacquard_common::CowStr<'a>,
    ///The IP address used when completing the AA flow.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub complete_ip: std::option::Option<jacquard_common::CowStr<'a>>,
    ///The user agent used when completing the AA flow.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub complete_ua: std::option::Option<jacquard_common::CowStr<'a>>,
    ///The date and time of this write operation.
    pub created_at: jacquard_common::types::string::Datetime,
    ///The IP address used when initiating the AA flow.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub init_ip: std::option::Option<jacquard_common::CowStr<'a>>,
    ///The user agent used when initiating the AA flow.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub init_ua: std::option::Option<jacquard_common::CowStr<'a>>,
    ///The status of the age assurance process.
    #[serde(borrow)]
    pub status: jacquard_common::CowStr<'a>,
}

impl jacquard_common::IntoStatic for AgeAssuranceEvent<'_> {
    type Output = AgeAssuranceEvent<'static>;
    fn into_static(self) -> Self::Output {
        AgeAssuranceEvent {
            attempt_id: self.attempt_id.into_static(),
            complete_ip: self.complete_ip.into_static(),
            complete_ua: self.complete_ua.into_static(),
            created_at: self.created_at.into_static(),
            init_ip: self.init_ip.into_static(),
            init_ua: self.init_ua.into_static(),
            status: self.status.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

///Age assurance status override by moderators. Only works on DID subjects.
#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct AgeAssuranceOverrideEvent<'a> {
    ///Comment describing the reason for the override.
    #[serde(borrow)]
    pub comment: jacquard_common::CowStr<'a>,
    ///The status to be set for the user decided by a moderator, overriding whatever value the user had previously. Use reset to default to original state.
    #[serde(borrow)]
    pub status: jacquard_common::CowStr<'a>,
}

impl jacquard_common::IntoStatic for AgeAssuranceOverrideEvent<'_> {
    type Output = AgeAssuranceOverrideEvent<'static>;
    fn into_static(self) -> Self::Output {
        AgeAssuranceOverrideEvent {
            comment: self.comment.into_static(),
            status: self.status.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct BlobView<'a> {
    #[serde(borrow)]
    pub cid: jacquard_common::types::string::Cid<'a>,
    pub created_at: jacquard_common::types::string::Datetime,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub details: std::option::Option<BlobViewRecordDetails<'a>>,
    #[serde(borrow)]
    pub mime_type: jacquard_common::CowStr<'a>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub moderation: std::option::Option<crate::tools_ozone::moderation::Moderation<'a>>,
    pub size: i64,
}

#[jacquard_derive::open_union]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(tag = "$type")]
#[serde(bound(deserialize = "'de: 'a"))]
pub enum BlobViewRecordDetails<'a> {}
impl jacquard_common::IntoStatic for BlobViewRecordDetails<'_> {
    type Output = BlobViewRecordDetails<'static>;
    fn into_static(self) -> Self::Output {
        match self {
            BlobViewRecordDetails::Unknown(v) => {
                BlobViewRecordDetails::Unknown(v.into_static())
            }
        }
    }
}

impl jacquard_common::IntoStatic for BlobView<'_> {
    type Output = BlobView<'static>;
    fn into_static(self) -> Self::Output {
        BlobView {
            cid: self.cid.into_static(),
            created_at: self.created_at.into_static(),
            details: self.details.into_static(),
            mime_type: self.mime_type.into_static(),
            moderation: self.moderation.into_static(),
            size: self.size.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

///Logs identity related events on a repo subject. Normally captured by automod from the firehose and emitted to ozone for historical tracking.
#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct IdentityEvent<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub comment: std::option::Option<jacquard_common::CowStr<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub handle: std::option::Option<jacquard_common::types::string::Handle<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub pds_host: std::option::Option<jacquard_common::types::string::Uri<'a>>,
    pub timestamp: jacquard_common::types::string::Datetime,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tombstone: std::option::Option<bool>,
}

impl jacquard_common::IntoStatic for IdentityEvent<'_> {
    type Output = IdentityEvent<'static>;
    fn into_static(self) -> Self::Output {
        IdentityEvent {
            comment: self.comment.into_static(),
            handle: self.handle.into_static(),
            pds_host: self.pds_host.into_static(),
            timestamp: self.timestamp.into_static(),
            tombstone: self.tombstone.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct ImageDetails<'a> {
    pub height: i64,
    pub width: i64,
}

impl jacquard_common::IntoStatic for ImageDetails<'_> {
    type Output = ImageDetails<'static>;
    fn into_static(self) -> Self::Output {
        ImageDetails {
            height: self.height.into_static(),
            width: self.width.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct ModEventAcknowledge<'a> {
    ///If true, all other reports on content authored by this account will be resolved (acknowledged).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub acknowledge_account_subjects: std::option::Option<bool>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub comment: std::option::Option<jacquard_common::CowStr<'a>>,
}

impl jacquard_common::IntoStatic for ModEventAcknowledge<'_> {
    type Output = ModEventAcknowledge<'static>;
    fn into_static(self) -> Self::Output {
        ModEventAcknowledge {
            acknowledge_account_subjects: self
                .acknowledge_account_subjects
                .into_static(),
            comment: self.comment.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

///Add a comment to a subject. An empty comment will clear any previously set sticky comment.
#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct ModEventComment<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub comment: std::option::Option<jacquard_common::CowStr<'a>>,
    ///Make the comment persistent on the subject
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sticky: std::option::Option<bool>,
}

impl jacquard_common::IntoStatic for ModEventComment<'_> {
    type Output = ModEventComment<'static>;
    fn into_static(self) -> Self::Output {
        ModEventComment {
            comment: self.comment.into_static(),
            sticky: self.sticky.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

///Divert a record's blobs to a 3rd party service for further scanning/tagging
#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct ModEventDivert<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub comment: std::option::Option<jacquard_common::CowStr<'a>>,
}

impl jacquard_common::IntoStatic for ModEventDivert<'_> {
    type Output = ModEventDivert<'static>;
    fn into_static(self) -> Self::Output {
        ModEventDivert {
            comment: self.comment.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

///Keep a log of outgoing email to a user
#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct ModEventEmail<'a> {
    ///Additional comment about the outgoing comm.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub comment: std::option::Option<jacquard_common::CowStr<'a>>,
    ///The content of the email sent to the user.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub content: std::option::Option<jacquard_common::CowStr<'a>>,
    ///The subject line of the email sent to the user.
    #[serde(borrow)]
    pub subject_line: jacquard_common::CowStr<'a>,
}

impl jacquard_common::IntoStatic for ModEventEmail<'_> {
    type Output = ModEventEmail<'static>;
    fn into_static(self) -> Self::Output {
        ModEventEmail {
            comment: self.comment.into_static(),
            content: self.content.into_static(),
            subject_line: self.subject_line.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct ModEventEscalate<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub comment: std::option::Option<jacquard_common::CowStr<'a>>,
}

impl jacquard_common::IntoStatic for ModEventEscalate<'_> {
    type Output = ModEventEscalate<'static>;
    fn into_static(self) -> Self::Output {
        ModEventEscalate {
            comment: self.comment.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

///Apply/Negate labels on a subject
#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct ModEventLabel<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub comment: std::option::Option<jacquard_common::CowStr<'a>>,
    #[serde(borrow)]
    pub create_label_vals: Vec<jacquard_common::CowStr<'a>>,
    ///Indicates how long the label will remain on the subject. Only applies on labels that are being added.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub duration_in_hours: std::option::Option<i64>,
    #[serde(borrow)]
    pub negate_label_vals: Vec<jacquard_common::CowStr<'a>>,
}

impl jacquard_common::IntoStatic for ModEventLabel<'_> {
    type Output = ModEventLabel<'static>;
    fn into_static(self) -> Self::Output {
        ModEventLabel {
            comment: self.comment.into_static(),
            create_label_vals: self.create_label_vals.into_static(),
            duration_in_hours: self.duration_in_hours.into_static(),
            negate_label_vals: self.negate_label_vals.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

///Mute incoming reports on a subject
#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct ModEventMute<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub comment: std::option::Option<jacquard_common::CowStr<'a>>,
    ///Indicates how long the subject should remain muted.
    pub duration_in_hours: i64,
}

impl jacquard_common::IntoStatic for ModEventMute<'_> {
    type Output = ModEventMute<'static>;
    fn into_static(self) -> Self::Output {
        ModEventMute {
            comment: self.comment.into_static(),
            duration_in_hours: self.duration_in_hours.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

///Mute incoming reports from an account
#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct ModEventMuteReporter<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub comment: std::option::Option<jacquard_common::CowStr<'a>>,
    ///Indicates how long the account should remain muted. Falsy value here means a permanent mute.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub duration_in_hours: std::option::Option<i64>,
}

impl jacquard_common::IntoStatic for ModEventMuteReporter<'_> {
    type Output = ModEventMuteReporter<'static>;
    fn into_static(self) -> Self::Output {
        ModEventMuteReporter {
            comment: self.comment.into_static(),
            duration_in_hours: self.duration_in_hours.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

///Set priority score of the subject. Higher score means higher priority.
#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct ModEventPriorityScore<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub comment: std::option::Option<jacquard_common::CowStr<'a>>,
    pub score: i64,
}

impl jacquard_common::IntoStatic for ModEventPriorityScore<'_> {
    type Output = ModEventPriorityScore<'static>;
    fn into_static(self) -> Self::Output {
        ModEventPriorityScore {
            comment: self.comment.into_static(),
            score: self.score.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

///Report a subject
#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct ModEventReport<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub comment: std::option::Option<jacquard_common::CowStr<'a>>,
    ///Set to true if the reporter was muted from reporting at the time of the event. These reports won't impact the reviewState of the subject.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub is_reporter_muted: std::option::Option<bool>,
    #[serde(borrow)]
    pub report_type: crate::com_atproto::moderation::ReasonType<'a>,
}

impl jacquard_common::IntoStatic for ModEventReport<'_> {
    type Output = ModEventReport<'static>;
    fn into_static(self) -> Self::Output {
        ModEventReport {
            comment: self.comment.into_static(),
            is_reporter_muted: self.is_reporter_muted.into_static(),
            report_type: self.report_type.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

///Resolve appeal on a subject
#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct ModEventResolveAppeal<'a> {
    ///Describe resolution.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub comment: std::option::Option<jacquard_common::CowStr<'a>>,
}

impl jacquard_common::IntoStatic for ModEventResolveAppeal<'_> {
    type Output = ModEventResolveAppeal<'static>;
    fn into_static(self) -> Self::Output {
        ModEventResolveAppeal {
            comment: self.comment.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

///Revert take down action on a subject
#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct ModEventReverseTakedown<'a> {
    ///Describe reasoning behind the reversal.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub comment: std::option::Option<jacquard_common::CowStr<'a>>,
}

impl jacquard_common::IntoStatic for ModEventReverseTakedown<'_> {
    type Output = ModEventReverseTakedown<'static>;
    fn into_static(self) -> Self::Output {
        ModEventReverseTakedown {
            comment: self.comment.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

///Add/Remove a tag on a subject
#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct ModEventTag<'a> {
    ///Tags to be added to the subject. If already exists, won't be duplicated.
    #[serde(borrow)]
    pub add: Vec<jacquard_common::CowStr<'a>>,
    ///Additional comment about added/removed tags.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub comment: std::option::Option<jacquard_common::CowStr<'a>>,
    ///Tags to be removed to the subject. Ignores a tag If it doesn't exist, won't be duplicated.
    #[serde(borrow)]
    pub remove: Vec<jacquard_common::CowStr<'a>>,
}

impl jacquard_common::IntoStatic for ModEventTag<'_> {
    type Output = ModEventTag<'static>;
    fn into_static(self) -> Self::Output {
        ModEventTag {
            add: self.add.into_static(),
            comment: self.comment.into_static(),
            remove: self.remove.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

///Take down a subject permanently or temporarily
#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct ModEventTakedown<'a> {
    ///If true, all other reports on content authored by this account will be resolved (acknowledged).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub acknowledge_account_subjects: std::option::Option<bool>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub comment: std::option::Option<jacquard_common::CowStr<'a>>,
    ///Indicates how long the takedown should be in effect before automatically expiring.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub duration_in_hours: std::option::Option<i64>,
    ///Names/Keywords of the policies that drove the decision.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub policies: std::option::Option<Vec<jacquard_common::CowStr<'a>>>,
}

impl jacquard_common::IntoStatic for ModEventTakedown<'_> {
    type Output = ModEventTakedown<'static>;
    fn into_static(self) -> Self::Output {
        ModEventTakedown {
            acknowledge_account_subjects: self
                .acknowledge_account_subjects
                .into_static(),
            comment: self.comment.into_static(),
            duration_in_hours: self.duration_in_hours.into_static(),
            policies: self.policies.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

///Unmute action on a subject
#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct ModEventUnmute<'a> {
    ///Describe reasoning behind the reversal.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub comment: std::option::Option<jacquard_common::CowStr<'a>>,
}

impl jacquard_common::IntoStatic for ModEventUnmute<'_> {
    type Output = ModEventUnmute<'static>;
    fn into_static(self) -> Self::Output {
        ModEventUnmute {
            comment: self.comment.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

///Unmute incoming reports from an account
#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct ModEventUnmuteReporter<'a> {
    ///Describe reasoning behind the reversal.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub comment: std::option::Option<jacquard_common::CowStr<'a>>,
}

impl jacquard_common::IntoStatic for ModEventUnmuteReporter<'_> {
    type Output = ModEventUnmuteReporter<'static>;
    fn into_static(self) -> Self::Output {
        ModEventUnmuteReporter {
            comment: self.comment.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct ModEventView<'a> {
    pub created_at: jacquard_common::types::string::Datetime,
    #[serde(borrow)]
    pub created_by: jacquard_common::types::string::Did<'a>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub creator_handle: std::option::Option<jacquard_common::CowStr<'a>>,
    #[serde(borrow)]
    pub event: ModEventViewRecordEvent<'a>,
    pub id: i64,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub mod_tool: std::option::Option<crate::tools_ozone::moderation::ModTool<'a>>,
    #[serde(borrow)]
    pub subject: ModEventViewRecordSubject<'a>,
    #[serde(borrow)]
    pub subject_blob_cids: Vec<jacquard_common::CowStr<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub subject_handle: std::option::Option<jacquard_common::CowStr<'a>>,
}

#[jacquard_derive::open_union]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(tag = "$type")]
#[serde(bound(deserialize = "'de: 'a"))]
pub enum ModEventViewRecordEvent<'a> {}
impl jacquard_common::IntoStatic for ModEventViewRecordEvent<'_> {
    type Output = ModEventViewRecordEvent<'static>;
    fn into_static(self) -> Self::Output {
        match self {
            ModEventViewRecordEvent::Unknown(v) => {
                ModEventViewRecordEvent::Unknown(v.into_static())
            }
        }
    }
}

#[jacquard_derive::open_union]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(tag = "$type")]
#[serde(bound(deserialize = "'de: 'a"))]
pub enum ModEventViewRecordSubject<'a> {
    #[serde(rename = "com.atproto.admin.defs#repoRef")]
    DefsRepoRef(Box<crate::com_atproto::admin::RepoRef<'a>>),
    #[serde(rename = "com.atproto.repo.strongRef")]
    StrongRef(Box<crate::com_atproto::repo::strong_ref::StrongRef<'a>>),
    #[serde(rename = "chat.bsky.convo.defs#messageRef")]
    DefsMessageRef(Box<crate::chat_bsky::convo::MessageRef<'a>>),
}

impl jacquard_common::IntoStatic for ModEventViewRecordSubject<'_> {
    type Output = ModEventViewRecordSubject<'static>;
    fn into_static(self) -> Self::Output {
        match self {
            ModEventViewRecordSubject::DefsRepoRef(v) => {
                ModEventViewRecordSubject::DefsRepoRef(v.into_static())
            }
            ModEventViewRecordSubject::StrongRef(v) => {
                ModEventViewRecordSubject::StrongRef(v.into_static())
            }
            ModEventViewRecordSubject::DefsMessageRef(v) => {
                ModEventViewRecordSubject::DefsMessageRef(v.into_static())
            }
            ModEventViewRecordSubject::Unknown(v) => {
                ModEventViewRecordSubject::Unknown(v.into_static())
            }
        }
    }
}

impl jacquard_common::IntoStatic for ModEventView<'_> {
    type Output = ModEventView<'static>;
    fn into_static(self) -> Self::Output {
        ModEventView {
            created_at: self.created_at.into_static(),
            created_by: self.created_by.into_static(),
            creator_handle: self.creator_handle.into_static(),
            event: self.event.into_static(),
            id: self.id.into_static(),
            mod_tool: self.mod_tool.into_static(),
            subject: self.subject.into_static(),
            subject_blob_cids: self.subject_blob_cids.into_static(),
            subject_handle: self.subject_handle.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct ModEventViewDetail<'a> {
    pub created_at: jacquard_common::types::string::Datetime,
    #[serde(borrow)]
    pub created_by: jacquard_common::types::string::Did<'a>,
    #[serde(borrow)]
    pub event: ModEventViewDetailRecordEvent<'a>,
    pub id: i64,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub mod_tool: std::option::Option<crate::tools_ozone::moderation::ModTool<'a>>,
    #[serde(borrow)]
    pub subject: ModEventViewDetailRecordSubject<'a>,
    #[serde(borrow)]
    pub subject_blobs: Vec<crate::tools_ozone::moderation::BlobView<'a>>,
}

#[jacquard_derive::open_union]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(tag = "$type")]
#[serde(bound(deserialize = "'de: 'a"))]
pub enum ModEventViewDetailRecordEvent<'a> {}
impl jacquard_common::IntoStatic for ModEventViewDetailRecordEvent<'_> {
    type Output = ModEventViewDetailRecordEvent<'static>;
    fn into_static(self) -> Self::Output {
        match self {
            ModEventViewDetailRecordEvent::Unknown(v) => {
                ModEventViewDetailRecordEvent::Unknown(v.into_static())
            }
        }
    }
}

#[jacquard_derive::open_union]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(tag = "$type")]
#[serde(bound(deserialize = "'de: 'a"))]
pub enum ModEventViewDetailRecordSubject<'a> {}
impl jacquard_common::IntoStatic for ModEventViewDetailRecordSubject<'_> {
    type Output = ModEventViewDetailRecordSubject<'static>;
    fn into_static(self) -> Self::Output {
        match self {
            ModEventViewDetailRecordSubject::Unknown(v) => {
                ModEventViewDetailRecordSubject::Unknown(v.into_static())
            }
        }
    }
}

impl jacquard_common::IntoStatic for ModEventViewDetail<'_> {
    type Output = ModEventViewDetail<'static>;
    fn into_static(self) -> Self::Output {
        ModEventViewDetail {
            created_at: self.created_at.into_static(),
            created_by: self.created_by.into_static(),
            event: self.event.into_static(),
            id: self.id.into_static(),
            mod_tool: self.mod_tool.into_static(),
            subject: self.subject.into_static(),
            subject_blobs: self.subject_blobs.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

///Moderation tool information for tracing the source of the action
#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct ModTool<'a> {
    ///Additional arbitrary metadata about the source
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub meta: std::option::Option<jacquard_common::types::value::Data<'a>>,
    ///Name/identifier of the source (e.g., 'automod', 'ozone/workspace')
    #[serde(borrow)]
    pub name: jacquard_common::CowStr<'a>,
}

impl jacquard_common::IntoStatic for ModTool<'_> {
    type Output = ModTool<'static>;
    fn into_static(self) -> Self::Output {
        ModTool {
            meta: self.meta.into_static(),
            name: self.name.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct Moderation<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub subject_status: std::option::Option<
        crate::tools_ozone::moderation::SubjectStatusView<'a>,
    >,
}

impl jacquard_common::IntoStatic for Moderation<'_> {
    type Output = Moderation<'static>;
    fn into_static(self) -> Self::Output {
        Moderation {
            subject_status: self.subject_status.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct ModerationDetail<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub subject_status: std::option::Option<
        crate::tools_ozone::moderation::SubjectStatusView<'a>,
    >,
}

impl jacquard_common::IntoStatic for ModerationDetail<'_> {
    type Output = ModerationDetail<'static>;
    fn into_static(self) -> Self::Output {
        ModerationDetail {
            subject_status: self.subject_status.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

///Logs lifecycle event on a record subject. Normally captured by automod from the firehose and emitted to ozone for historical tracking.
#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct RecordEvent<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub cid: std::option::Option<jacquard_common::types::string::Cid<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub comment: std::option::Option<jacquard_common::CowStr<'a>>,
    #[serde(borrow)]
    pub op: jacquard_common::CowStr<'a>,
    pub timestamp: jacquard_common::types::string::Datetime,
}

impl jacquard_common::IntoStatic for RecordEvent<'_> {
    type Output = RecordEvent<'static>;
    fn into_static(self) -> Self::Output {
        RecordEvent {
            cid: self.cid.into_static(),
            comment: self.comment.into_static(),
            op: self.op.into_static(),
            timestamp: self.timestamp.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct RecordHosting<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub created_at: std::option::Option<jacquard_common::types::string::Datetime>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deleted_at: std::option::Option<jacquard_common::types::string::Datetime>,
    #[serde(borrow)]
    pub status: jacquard_common::CowStr<'a>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub updated_at: std::option::Option<jacquard_common::types::string::Datetime>,
}

impl jacquard_common::IntoStatic for RecordHosting<'_> {
    type Output = RecordHosting<'static>;
    fn into_static(self) -> Self::Output {
        RecordHosting {
            created_at: self.created_at.into_static(),
            deleted_at: self.deleted_at.into_static(),
            status: self.status.into_static(),
            updated_at: self.updated_at.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct RecordView<'a> {
    #[serde(borrow)]
    pub blob_cids: Vec<jacquard_common::types::string::Cid<'a>>,
    #[serde(borrow)]
    pub cid: jacquard_common::types::string::Cid<'a>,
    pub indexed_at: jacquard_common::types::string::Datetime,
    #[serde(borrow)]
    pub moderation: crate::tools_ozone::moderation::Moderation<'a>,
    #[serde(borrow)]
    pub repo: crate::tools_ozone::moderation::RepoView<'a>,
    #[serde(borrow)]
    pub uri: jacquard_common::types::string::AtUri<'a>,
    #[serde(borrow)]
    pub value: jacquard_common::types::value::Data<'a>,
}

impl jacquard_common::IntoStatic for RecordView<'_> {
    type Output = RecordView<'static>;
    fn into_static(self) -> Self::Output {
        RecordView {
            blob_cids: self.blob_cids.into_static(),
            cid: self.cid.into_static(),
            indexed_at: self.indexed_at.into_static(),
            moderation: self.moderation.into_static(),
            repo: self.repo.into_static(),
            uri: self.uri.into_static(),
            value: self.value.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct RecordViewDetail<'a> {
    #[serde(borrow)]
    pub blobs: Vec<crate::tools_ozone::moderation::BlobView<'a>>,
    #[serde(borrow)]
    pub cid: jacquard_common::types::string::Cid<'a>,
    pub indexed_at: jacquard_common::types::string::Datetime,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub labels: std::option::Option<Vec<crate::com_atproto::label::Label<'a>>>,
    #[serde(borrow)]
    pub moderation: crate::tools_ozone::moderation::ModerationDetail<'a>,
    #[serde(borrow)]
    pub repo: crate::tools_ozone::moderation::RepoView<'a>,
    #[serde(borrow)]
    pub uri: jacquard_common::types::string::AtUri<'a>,
    #[serde(borrow)]
    pub value: jacquard_common::types::value::Data<'a>,
}

impl jacquard_common::IntoStatic for RecordViewDetail<'_> {
    type Output = RecordViewDetail<'static>;
    fn into_static(self) -> Self::Output {
        RecordViewDetail {
            blobs: self.blobs.into_static(),
            cid: self.cid.into_static(),
            indexed_at: self.indexed_at.into_static(),
            labels: self.labels.into_static(),
            moderation: self.moderation.into_static(),
            repo: self.repo.into_static(),
            uri: self.uri.into_static(),
            value: self.value.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct RecordViewNotFound<'a> {
    #[serde(borrow)]
    pub uri: jacquard_common::types::string::AtUri<'a>,
}

impl jacquard_common::IntoStatic for RecordViewNotFound<'_> {
    type Output = RecordViewNotFound<'static>;
    fn into_static(self) -> Self::Output {
        RecordViewNotFound {
            uri: self.uri.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

///Statistics about a set of record subject items
#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct RecordsStats<'a> {
    ///Number of items that were appealed at least once
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub appealed_count: std::option::Option<i64>,
    ///Number of items that were escalated at least once
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub escalated_count: std::option::Option<i64>,
    ///Number of item currently in "reviewOpen" or "reviewEscalated" state
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub pending_count: std::option::Option<i64>,
    ///Number of item currently in "reviewNone" or "reviewClosed" state
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub processed_count: std::option::Option<i64>,
    ///Number of items that were reported at least once
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reported_count: std::option::Option<i64>,
    ///Total number of item in the set
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub subject_count: std::option::Option<i64>,
    ///Number of item currently taken down
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub takendown_count: std::option::Option<i64>,
    ///Cumulative sum of the number of reports on the items in the set
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub total_reports: std::option::Option<i64>,
}

impl jacquard_common::IntoStatic for RecordsStats<'_> {
    type Output = RecordsStats<'static>;
    fn into_static(self) -> Self::Output {
        RecordsStats {
            appealed_count: self.appealed_count.into_static(),
            escalated_count: self.escalated_count.into_static(),
            pending_count: self.pending_count.into_static(),
            processed_count: self.processed_count.into_static(),
            reported_count: self.reported_count.into_static(),
            subject_count: self.subject_count.into_static(),
            takendown_count: self.takendown_count.into_static(),
            total_reports: self.total_reports.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct RepoView<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deactivated_at: std::option::Option<jacquard_common::types::string::Datetime>,
    #[serde(borrow)]
    pub did: jacquard_common::types::string::Did<'a>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub email: std::option::Option<jacquard_common::CowStr<'a>>,
    #[serde(borrow)]
    pub handle: jacquard_common::types::string::Handle<'a>,
    pub indexed_at: jacquard_common::types::string::Datetime,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub invite_note: std::option::Option<jacquard_common::CowStr<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub invited_by: std::option::Option<crate::com_atproto::server::InviteCode<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub invites_disabled: std::option::Option<bool>,
    #[serde(borrow)]
    pub moderation: crate::tools_ozone::moderation::Moderation<'a>,
    #[serde(borrow)]
    pub related_records: Vec<jacquard_common::types::value::Data<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub threat_signatures: std::option::Option<
        Vec<crate::com_atproto::admin::ThreatSignature<'a>>,
    >,
}

impl jacquard_common::IntoStatic for RepoView<'_> {
    type Output = RepoView<'static>;
    fn into_static(self) -> Self::Output {
        RepoView {
            deactivated_at: self.deactivated_at.into_static(),
            did: self.did.into_static(),
            email: self.email.into_static(),
            handle: self.handle.into_static(),
            indexed_at: self.indexed_at.into_static(),
            invite_note: self.invite_note.into_static(),
            invited_by: self.invited_by.into_static(),
            invites_disabled: self.invites_disabled.into_static(),
            moderation: self.moderation.into_static(),
            related_records: self.related_records.into_static(),
            threat_signatures: self.threat_signatures.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct RepoViewDetail<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deactivated_at: std::option::Option<jacquard_common::types::string::Datetime>,
    #[serde(borrow)]
    pub did: jacquard_common::types::string::Did<'a>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub email: std::option::Option<jacquard_common::CowStr<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub email_confirmed_at: std::option::Option<
        jacquard_common::types::string::Datetime,
    >,
    #[serde(borrow)]
    pub handle: jacquard_common::types::string::Handle<'a>,
    pub indexed_at: jacquard_common::types::string::Datetime,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub invite_note: std::option::Option<jacquard_common::CowStr<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub invited_by: std::option::Option<crate::com_atproto::server::InviteCode<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub invites: std::option::Option<Vec<crate::com_atproto::server::InviteCode<'a>>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub invites_disabled: std::option::Option<bool>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub labels: std::option::Option<Vec<crate::com_atproto::label::Label<'a>>>,
    #[serde(borrow)]
    pub moderation: crate::tools_ozone::moderation::ModerationDetail<'a>,
    #[serde(borrow)]
    pub related_records: Vec<jacquard_common::types::value::Data<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub threat_signatures: std::option::Option<
        Vec<crate::com_atproto::admin::ThreatSignature<'a>>,
    >,
}

impl jacquard_common::IntoStatic for RepoViewDetail<'_> {
    type Output = RepoViewDetail<'static>;
    fn into_static(self) -> Self::Output {
        RepoViewDetail {
            deactivated_at: self.deactivated_at.into_static(),
            did: self.did.into_static(),
            email: self.email.into_static(),
            email_confirmed_at: self.email_confirmed_at.into_static(),
            handle: self.handle.into_static(),
            indexed_at: self.indexed_at.into_static(),
            invite_note: self.invite_note.into_static(),
            invited_by: self.invited_by.into_static(),
            invites: self.invites.into_static(),
            invites_disabled: self.invites_disabled.into_static(),
            labels: self.labels.into_static(),
            moderation: self.moderation.into_static(),
            related_records: self.related_records.into_static(),
            threat_signatures: self.threat_signatures.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct RepoViewNotFound<'a> {
    #[serde(borrow)]
    pub did: jacquard_common::types::string::Did<'a>,
}

impl jacquard_common::IntoStatic for RepoViewNotFound<'_> {
    type Output = RepoViewNotFound<'static>;
    fn into_static(self) -> Self::Output {
        RepoViewNotFound {
            did: self.did.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct ReporterStats<'a> {
    ///The total number of reports made by the user on accounts.
    pub account_report_count: i64,
    #[serde(borrow)]
    pub did: jacquard_common::types::string::Did<'a>,
    ///The total number of accounts labeled as a result of the user's reports.
    pub labeled_account_count: i64,
    ///The total number of records labeled as a result of the user's reports.
    pub labeled_record_count: i64,
    ///The total number of reports made by the user on records.
    pub record_report_count: i64,
    ///The total number of accounts reported by the user.
    pub reported_account_count: i64,
    ///The total number of records reported by the user.
    pub reported_record_count: i64,
    ///The total number of accounts taken down as a result of the user's reports.
    pub takendown_account_count: i64,
    ///The total number of records taken down as a result of the user's reports.
    pub takendown_record_count: i64,
}

impl jacquard_common::IntoStatic for ReporterStats<'_> {
    type Output = ReporterStats<'static>;
    fn into_static(self) -> Self::Output {
        ReporterStats {
            account_report_count: self.account_report_count.into_static(),
            did: self.did.into_static(),
            labeled_account_count: self.labeled_account_count.into_static(),
            labeled_record_count: self.labeled_record_count.into_static(),
            record_report_count: self.record_report_count.into_static(),
            reported_account_count: self.reported_account_count.into_static(),
            reported_record_count: self.reported_record_count.into_static(),
            takendown_account_count: self.takendown_account_count.into_static(),
            takendown_record_count: self.takendown_record_count.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

///Account credentials revocation by moderators. Only works on DID subjects.
#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct RevokeAccountCredentialsEvent<'a> {
    ///Comment describing the reason for the revocation.
    #[serde(borrow)]
    pub comment: jacquard_common::CowStr<'a>,
}

impl jacquard_common::IntoStatic for RevokeAccountCredentialsEvent<'_> {
    type Output = RevokeAccountCredentialsEvent<'static>;
    fn into_static(self) -> Self::Output {
        RevokeAccountCredentialsEvent {
            comment: self.comment.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum SubjectReviewState<'a> {
    ReviewOpen,
    ReviewEscalated,
    ReviewClosed,
    ReviewNone,
    Other(jacquard_common::CowStr<'a>),
}

impl<'a> SubjectReviewState<'a> {
    pub fn as_str(&self) -> &str {
        match self {
            Self::ReviewOpen => "#reviewOpen",
            Self::ReviewEscalated => "#reviewEscalated",
            Self::ReviewClosed => "#reviewClosed",
            Self::ReviewNone => "#reviewNone",
            Self::Other(s) => s.as_ref(),
        }
    }
}

impl<'a> From<&'a str> for SubjectReviewState<'a> {
    fn from(s: &'a str) -> Self {
        match s {
            "#reviewOpen" => Self::ReviewOpen,
            "#reviewEscalated" => Self::ReviewEscalated,
            "#reviewClosed" => Self::ReviewClosed,
            "#reviewNone" => Self::ReviewNone,
            _ => Self::Other(jacquard_common::CowStr::from(s)),
        }
    }
}

impl<'a> From<String> for SubjectReviewState<'a> {
    fn from(s: String) -> Self {
        match s.as_str() {
            "#reviewOpen" => Self::ReviewOpen,
            "#reviewEscalated" => Self::ReviewEscalated,
            "#reviewClosed" => Self::ReviewClosed,
            "#reviewNone" => Self::ReviewNone,
            _ => Self::Other(jacquard_common::CowStr::from(s)),
        }
    }
}

impl<'a> AsRef<str> for SubjectReviewState<'a> {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

impl<'a> serde::Serialize for SubjectReviewState<'a> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(self.as_str())
    }
}

impl<'de, 'a> serde::Deserialize<'de> for SubjectReviewState<'a>
where
    'de: 'a,
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let s = <&'de str>::deserialize(deserializer)?;
        Ok(Self::from(s))
    }
}

impl jacquard_common::IntoStatic for SubjectReviewState<'_> {
    type Output = SubjectReviewState<'static>;
    fn into_static(self) -> Self::Output {
        match self {
            SubjectReviewState::ReviewOpen => SubjectReviewState::ReviewOpen,
            SubjectReviewState::ReviewEscalated => SubjectReviewState::ReviewEscalated,
            SubjectReviewState::ReviewClosed => SubjectReviewState::ReviewClosed,
            SubjectReviewState::ReviewNone => SubjectReviewState::ReviewNone,
            SubjectReviewState::Other(v) => SubjectReviewState::Other(v.into_static()),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct SubjectStatusView<'a> {
    ///Statistics related to the account subject
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub account_stats: std::option::Option<
        crate::tools_ozone::moderation::AccountStats<'a>,
    >,
    ///Current age assurance state of the subject.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub age_assurance_state: std::option::Option<jacquard_common::CowStr<'a>>,
    ///Whether or not the last successful update to age assurance was made by the user or admin.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub age_assurance_updated_by: std::option::Option<jacquard_common::CowStr<'a>>,
    ///True indicates that the a previously taken moderator action was appealed against, by the author of the content. False indicates last appeal was resolved by moderators.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub appealed: std::option::Option<bool>,
    ///Sticky comment on the subject.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub comment: std::option::Option<jacquard_common::CowStr<'a>>,
    ///Timestamp referencing the first moderation status impacting event was emitted on the subject
    pub created_at: jacquard_common::types::string::Datetime,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub hosting: std::option::Option<SubjectStatusViewRecordHosting<'a>>,
    pub id: i64,
    ///Timestamp referencing when the author of the subject appealed a moderation action
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_appealed_at: std::option::Option<jacquard_common::types::string::Datetime>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_reported_at: std::option::Option<jacquard_common::types::string::Datetime>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_reviewed_at: std::option::Option<jacquard_common::types::string::Datetime>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub last_reviewed_by: std::option::Option<jacquard_common::types::string::Did<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub mute_reporting_until: std::option::Option<
        jacquard_common::types::string::Datetime,
    >,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub mute_until: std::option::Option<jacquard_common::types::string::Datetime>,
    ///Numeric value representing the level of priority. Higher score means higher priority.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub priority_score: std::option::Option<i64>,
    ///Statistics related to the record subjects authored by the subject's account
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub records_stats: std::option::Option<
        crate::tools_ozone::moderation::RecordsStats<'a>,
    >,
    #[serde(borrow)]
    pub review_state: crate::tools_ozone::moderation::SubjectReviewState<'a>,
    #[serde(borrow)]
    pub subject: SubjectStatusViewRecordSubject<'a>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub subject_blob_cids: std::option::Option<
        Vec<jacquard_common::types::string::Cid<'a>>,
    >,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub subject_repo_handle: std::option::Option<jacquard_common::CowStr<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub suspend_until: std::option::Option<jacquard_common::types::string::Datetime>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub tags: std::option::Option<Vec<jacquard_common::CowStr<'a>>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub takendown: std::option::Option<bool>,
    ///Timestamp referencing when the last update was made to the moderation status of the subject
    pub updated_at: jacquard_common::types::string::Datetime,
}

#[jacquard_derive::open_union]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(tag = "$type")]
#[serde(bound(deserialize = "'de: 'a"))]
pub enum SubjectStatusViewRecordHosting<'a> {}
impl jacquard_common::IntoStatic for SubjectStatusViewRecordHosting<'_> {
    type Output = SubjectStatusViewRecordHosting<'static>;
    fn into_static(self) -> Self::Output {
        match self {
            SubjectStatusViewRecordHosting::Unknown(v) => {
                SubjectStatusViewRecordHosting::Unknown(v.into_static())
            }
        }
    }
}

#[jacquard_derive::open_union]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(tag = "$type")]
#[serde(bound(deserialize = "'de: 'a"))]
pub enum SubjectStatusViewRecordSubject<'a> {
    #[serde(rename = "com.atproto.admin.defs#repoRef")]
    DefsRepoRef(Box<crate::com_atproto::admin::RepoRef<'a>>),
    #[serde(rename = "com.atproto.repo.strongRef")]
    StrongRef(Box<crate::com_atproto::repo::strong_ref::StrongRef<'a>>),
    #[serde(rename = "chat.bsky.convo.defs#messageRef")]
    DefsMessageRef(Box<crate::chat_bsky::convo::MessageRef<'a>>),
}

impl jacquard_common::IntoStatic for SubjectStatusViewRecordSubject<'_> {
    type Output = SubjectStatusViewRecordSubject<'static>;
    fn into_static(self) -> Self::Output {
        match self {
            SubjectStatusViewRecordSubject::DefsRepoRef(v) => {
                SubjectStatusViewRecordSubject::DefsRepoRef(v.into_static())
            }
            SubjectStatusViewRecordSubject::StrongRef(v) => {
                SubjectStatusViewRecordSubject::StrongRef(v.into_static())
            }
            SubjectStatusViewRecordSubject::DefsMessageRef(v) => {
                SubjectStatusViewRecordSubject::DefsMessageRef(v.into_static())
            }
            SubjectStatusViewRecordSubject::Unknown(v) => {
                SubjectStatusViewRecordSubject::Unknown(v.into_static())
            }
        }
    }
}

impl jacquard_common::IntoStatic for SubjectStatusView<'_> {
    type Output = SubjectStatusView<'static>;
    fn into_static(self) -> Self::Output {
        SubjectStatusView {
            account_stats: self.account_stats.into_static(),
            age_assurance_state: self.age_assurance_state.into_static(),
            age_assurance_updated_by: self.age_assurance_updated_by.into_static(),
            appealed: self.appealed.into_static(),
            comment: self.comment.into_static(),
            created_at: self.created_at.into_static(),
            hosting: self.hosting.into_static(),
            id: self.id.into_static(),
            last_appealed_at: self.last_appealed_at.into_static(),
            last_reported_at: self.last_reported_at.into_static(),
            last_reviewed_at: self.last_reviewed_at.into_static(),
            last_reviewed_by: self.last_reviewed_by.into_static(),
            mute_reporting_until: self.mute_reporting_until.into_static(),
            mute_until: self.mute_until.into_static(),
            priority_score: self.priority_score.into_static(),
            records_stats: self.records_stats.into_static(),
            review_state: self.review_state.into_static(),
            subject: self.subject.into_static(),
            subject_blob_cids: self.subject_blob_cids.into_static(),
            subject_repo_handle: self.subject_repo_handle.into_static(),
            suspend_until: self.suspend_until.into_static(),
            tags: self.tags.into_static(),
            takendown: self.takendown.into_static(),
            updated_at: self.updated_at.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

///Detailed view of a subject. For record subjects, the author's repo and profile will be returned.
#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct SubjectView<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub profile: std::option::Option<SubjectViewRecordProfile<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub record: std::option::Option<
        crate::tools_ozone::moderation::RecordViewDetail<'a>,
    >,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub repo: std::option::Option<crate::tools_ozone::moderation::RepoViewDetail<'a>>,
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub status: std::option::Option<
        crate::tools_ozone::moderation::SubjectStatusView<'a>,
    >,
    #[serde(borrow)]
    pub subject: jacquard_common::CowStr<'a>,
    #[serde(borrow)]
    pub r#type: crate::com_atproto::moderation::SubjectType<'a>,
}

#[jacquard_derive::open_union]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(tag = "$type")]
#[serde(bound(deserialize = "'de: 'a"))]
pub enum SubjectViewRecordProfile<'a> {}
impl jacquard_common::IntoStatic for SubjectViewRecordProfile<'_> {
    type Output = SubjectViewRecordProfile<'static>;
    fn into_static(self) -> Self::Output {
        match self {
            SubjectViewRecordProfile::Unknown(v) => {
                SubjectViewRecordProfile::Unknown(v.into_static())
            }
        }
    }
}

impl jacquard_common::IntoStatic for SubjectView<'_> {
    type Output = SubjectView<'static>;
    fn into_static(self) -> Self::Output {
        SubjectView {
            profile: self.profile.into_static(),
            record: self.record.into_static(),
            repo: self.repo.into_static(),
            status: self.status.into_static(),
            subject: self.subject.into_static(),
            r#type: self.r#type.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}

#[jacquard_derive::lexicon]
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct VideoDetails<'a> {
    pub height: i64,
    pub length: i64,
    pub width: i64,
}

impl jacquard_common::IntoStatic for VideoDetails<'_> {
    type Output = VideoDetails<'static>;
    fn into_static(self) -> Self::Output {
        VideoDetails {
            height: self.height.into_static(),
            length: self.length.into_static(),
            width: self.width.into_static(),
            extra_data: self.extra_data.into_static(),
        }
    }
}